# 任务计划: 收尾 `sog4d-sequence-format`(验证 + 归档)

## 目标
完成 `.sog4d`/`.sog4d.zip` 的实现收尾验证.
把本次 change 正式归档,让仓库回到"可继续下一件事"的干净状态.

## 阶段
- [x] 阶段1: 状态确认与收尾规划
- [x] 阶段2: 运行可用验证(非 Unity)
- [x] 阶段3: 四文件收尾(WORKLOG/notes/LATER_PLANS/ERRORFIX)
- [x] 阶段4: 归档 OpenSpec change

## 关键问题
1. 在当前环境不启动 Unity 的前提下,我们还能做哪些"证据型"验证.
2. Python 导出工具的 validate 子命令,是否能在未安装训练依赖(sklearn 等)时独立运行.

## 做出的决定
- [决定] 因为 `task_plan.md` 已超过 1000 行,按规范先续档并新开一份.
  - 理由: 减少注意力污染,也符合"文件系统作为外部内存"的维护成本控制.

## 状态
**已完成**.
时间: 2026-02-18 22:23:00 +0800.
我已完成 specs 同步与 change 归档,并通过 strict 校验验证仓库 specs 一致性.

## 进展记录
### 2026-02-18 22:08:25 +0800
- 已确认 change 状态:
  - `openspec list --json` 显示 `sog4d-sequence-format` 为 complete(38/38).
  - `openspec validate sog4d-sequence-format --strict` 通过.
- 已完成可执行验证(不启动 Unity):
  - Python exporter 自检通过:
    - `python3 Tools~/Sog4D/ply_sequence_to_sog4d.py validate --input Tests/Editor/Sog4DTestData/minimal_valid_delta_v1.sog4d.zip`
  - Python 语法编译检查通过:
    - `python3 -m compileall Tools~/Sog4D -q`
- 下一步进入阶段3:
  - 收尾更新 `WORKLOG.md/notes.md/LATER_PLANS.md`(以及如有必要的 `ERRORFIX.md`).
  - 然后归档 OpenSpec change.

### 2026-02-18 22:15:06 +0800
- 已完成阶段3(四文件收尾):
  - `notes.md`: 追加 continuous-learning 四文件摘要.
  - `WORKLOG.md`: 追加收尾验证记录与下一步(同步 specs + 归档 change).
  - `LATER_PLANS.md`: 清理已完成的 "序列 4DGS 新格式" 候选项(避免备忘污染).
  - `AGENTS.md`: 追加 "Samples copy 不自动更新" 的长期提醒(项目级约定).
  - 历史版本归档:
    - `archive/task_plan_2026-02-18_220625.md`
- 下一步进入阶段4:
  - 先把 `openspec/changes/sog4d-sequence-format/specs/**` 同步到 `openspec/specs/**`.
  - 然后把 change 归档到 `openspec/changes/archive/`.

### 2026-02-18 22:23:00 +0800
- 已完成阶段4(specs 同步 + 归档):
  - specs 同步:
    - 新增 `openspec/specs/sog4d-*/spec.md` 与 `openspec/specs/4dgs-keyframe-motion/spec.md`
    - 更新 `openspec/specs/4dgs-resource-budgeting/spec.md`(纳入 `.sog4d` 路径的预算与降级项)
  - strict 校验:
    - `openspec validate --specs --strict` 通过
    - `openspec validate --all --strict` 通过
  - 归档:
    - `openspec/changes/archive/2026-02-18-sog4d-sequence-format/`
    - `openspec list --json` 显示无 active changes

---

# 任务计划: 修复 Unity 编译歧义引用(CS0104)

## 目标
修复 `.sog4d` importer 与其 EditMode tests 在 Unity 下的编译错误:
- CS0104: `CompressionLevel` 歧义引用
- CS0104: `Object` 歧义引用

使 `Gsplat.Tests.Editor` 能正常编译并继续执行回归测试.

## 阶段
- [x] 阶段1: 定位歧义来源与影响范围
- [x] 阶段2: 以最小侵入方式消除歧义
- [x] 阶段3: Unity 侧重新编译与测试验证

## 状态
**已完成**.
时间: 2026-02-19 10:34:20 +0800.
Unity 已重新编译并执行 `Gsplat.Tests.Editor`(EditMode),未再出现 CS0104.

## 进展记录
### 2026-02-19 10:11:17 +0800
- 现象(来自 Unity Console):
  - `Tests/Editor/GsplatSog4DImporterTests.cs`: `CompressionLevel` 在 `System.IO.Compression` 与 `UnityEngine` 之间歧义.
  - `Editor/GsplatSog4DImporter.cs`: `Object` 在 `UnityEngine.Object` 与 `object`(System.Object)之间歧义.
- 根因:
  - 文件同时 `using System.IO.Compression;` 与 `using UnityEngine;`,且两侧都暴露同名类型.
- 修复:
  - `Tests/Editor/GsplatSog4DImporterTests.cs`:
    - 增加别名 `using ZipCompressionLevel = System.IO.Compression.CompressionLevel;`
    - `CreateEntry(..., CompressionLevel.NoCompression)` 改为 `CreateEntry(..., ZipCompressionLevel.NoCompression)`
  - `Editor/GsplatSog4DImporter.cs`:
    - 增加别名 `using Object = UnityEngine.Object;`,统一 `Object.DestroyImmediate(...)` 的含义
- 下一步:
  - 在 Unity Test Runner 里重新编译并运行 `Gsplat.Tests.Editor`.

### 2026-02-19 10:34:20 +0800
- Unity EditMode tests 已实际执行并产出测试报告:
  - `TestResults.xml`: `/Users/cuiluming/Library/Application Support/DefaultCompany/st-dongfeng-worldmodel/TestResults.xml`
  - 汇总: total=17, passed=11, failed=0, skipped=6
- Console 中看到的多条 `import error:` 为测试用例刻意导入坏数据以验证"可操作的报错信息",属于预期现象.
- skipped 的 6 个用例原因:
  - `当前 Unity 版本不支持 WebP 解码,跳过需要解码的测试.`

---

# 任务计划: 让 WebP 解码可用(跑满 `.sog4d` importer tests)

## 目标
让 `Gsplat.Tests.Editor` 中被 Ignore 的 6 个用例跑起来.
核心是: 在 Unity `ImageConversion.LoadImage` 不支持 WebP 的环境下,依然能解码 `.webp` 数据图.

## 阶段
- [x] 阶段1: 规划与风险评估(两条路线)
- [x] 阶段2: 研究 Unity/平台可用的 WebP 解码方案
- [x] 阶段3: 落地实现(Importer + Tests)
- [x] 阶段4: Unity 侧回归验证(不再 skipped)

## 两条路线(需要做选择)
### 路线A(不惜代价,最佳方案): 内置 WebP 解码器
- 做法:
  - 在包内提供一个可用的 WebP 解码器(优先: `libwebp` 原生库 + C# P/Invoke 包装).
  - Importer 先尝试 `ImageConversion.LoadImage`,失败后自动走内置解码器.
  - Tests 改为基于“与 importer 同源的 decoder 探测”,不再被 `ImageConversion.LoadImage==false` 误伤而 Ignore.
- 优点:
  - 行为稳定,与 Unity 版本解耦.
  - 满足 spec 对“数据图 byte 必须一致”的要求(使用 `libwebp` lossless 解码).
- 代价:
  - 引入原生插件(需要考虑 macOS/Windows/Linux Editor 的二进制分发与 .meta).

### 路线B(先能用,后面再优雅): 借用 Unity 资产导入链路解码
- 做法:
  - 把 zip 内 `.webp` 临时写到 `Assets/__Temp/xxx.webp`,用 `AssetDatabase.ImportAsset` 让 Unity 纹理导入器解码,
    再读回像素做数据图处理.
- 优点:
  - 不引入第三方二进制.
- 风险/缺点:
  - 依赖 Unity 是否“能导入 WebP 纹理”(不确定性很高).
  - 需要频繁磁盘 IO,并且更容易在测试/并发导入场景出幺蛾子.

## 做出的决定
- [决定] 选择路线A: 内置 `libwebp` 解码器,彻底消除 Unity 版本差异.
  - 理由: `.sog4d` 的 WebP 是“数据图”,必须 lossless 且 byte 精确; 依赖 Unity 导入链路属于黑盒且不稳定.

## 关键问题
1. 我们要覆盖哪些平台: 仅 macOS Editor 先跑通,还是一次性补齐 Win/Linux Editor?
2. 原生库的落点与命名: 如何避免与其它包的 `libwebp` 冲突,并保持可维护性.

## 状态
**已完成**.
时间: 2026-02-19 11:17:50 +0800.
我已为 macOS Editor 内置 `libwebp` 解码器,并让 `.sog4d` importer tests 不再 skipped.

## 进展记录
### 2026-02-19 11:17:50 +0800
- 根因确认:
  - `ImageConversion.LoadImage` 在当前 Unity 版本对 WebP 返回 false,导致 tests 触发 `Assert.Ignore`.
- 落地实现(路线A):
  - 新增 macOS Editor 原生库: `Editor/Plugins/macOS/libGsplatWebpDecoder.dylib`(universal: arm64+x86_64).
  - 新增 C# P/Invoke 包装: `Editor/GsplatWebpNative.cs`,提供 `TryDecodeRgba32/SupportsWebpDecoding`.
  - Importer fallback:
    - `Editor/GsplatSog4DImporter.cs`: `LoadImage` 失败后自动调用 `GsplatWebpNative.TryDecodeRgba32`,
      并用 `Texture2D.LoadRawTextureData` 填充数据图.
  - Tests 能力探测改造:
    - `Tests/Editor/GsplatSog4DImporterTests.cs`: `SupportsWebpDecoding` 改为反射调用 `GsplatWebpNative.SupportsWebpDecoding`,
      避免对 `Gsplat.Editor` 产生编译期依赖.
- 回归验证(证据):
  - 使用 Unity 6000.3.8f1 在临时工程中跑测试:
    - `Gsplat.Tests.GsplatSog4DImporterTests`: passed=10, failed=0, skipped=0

---

# 任务计划: 让那 6 个 skipped 用例也能跑起来(WebP 解码稳态)

## 目标
让 `Gsplat.Tests.Editor` 里原本 skipped 的 6 个 `.sog4d` importer 用例不再跳过.
结束状态是: 同一套 EditMode tests 在当前工程中实际执行,并且 `skipped=0`.

## 阶段
- [x] 阶段1: 复盘 skipped 的来源与时间线
- [x] 阶段2: 核对 WebP 解码 fallback 是否已落盘
- [x] 阶段3: 补齐 native plugin 的 `.meta`(避免 Unity 识别/加载不稳定)
- [x] 阶段4: Unity 侧重新跑测试并存证

## 关键问题
1. skipped 是否来自旧的 `TestResults.xml`,还是“重新跑依然 skip”.
2. `.dylib` 是否被 Unity 当作 native plugin 导入(缺 `.meta` 时可能不稳定).
3. tests 的“能力探测”是否与 importer 的解码路径一致.

## 做出的决定
- [决定] 先把 skipped 的时间线搞清楚,再补齐 `.meta` 做稳态.
  - 理由: 你现在贴出来的 `TestResults.xml` 时间是 2026-02-19 10:34:12 +0800,
    但 WebP decoder 相关文件是在 11:00+ 才新增.
    这很可能是“修复已落盘,但还没重新跑测试”的典型情况.

## 状态
**已完成**
时间: 2026-02-19 11:55:25 +0800.
我已补齐 native plugin 的 `.meta`,并确保 tests 的 WebP 探测逻辑与 importer 的解码路径一致.
同时补上 batchmode/nographics 的 guard,避免无图形设备时的 compute kernel error log 让单测误失败.

## 进展记录
### 2026-02-19 11:46:23 +0800
- 你这次看到的 skipped=6 来自测试报告:
  - `/Users/cuiluming/Library/Application Support/DefaultCompany/st-dongfeng-worldmodel/TestResults.xml`
  - mtime: 2026-02-19 10:34:12 +0800
  - skipped 原因: "当前 Unity 版本不支持 WebP 解码..."
- 但包内 WebP fallback 已经在稍后落盘(文件 mtime):
  - `Editor/Plugins/macOS/libGsplatWebpDecoder.dylib`: 2026-02-19 11:00:52 +0800
  - `Editor/GsplatWebpNative.cs`: 2026-02-19 11:01:37 +0800
  - `Tests/Editor/GsplatSog4DImporterTests.cs`: 2026-02-19 11:02:48 +0800
- 下一步进入阶段3:
  - 为 `Editor/Plugins/**` 补齐 `.meta`,降低 Unity 导入期自动生成 meta 的不确定性.

### 2026-02-19 11:55:25 +0800
- 已补齐 native plugin 的 `.meta`(稳态):
  - `Editor/Plugins.meta`
  - `Editor/Plugins/macOS.meta`
  - `Editor/Plugins/macOS/libGsplatWebpDecoder.dylib.meta`
- tests 的 WebP 能力探测改造:
  - `Tests/Editor/GsplatSog4DImporterTests.cs`: 先尝试 `ImageConversion.LoadImage`,失败再反射调用 `Gsplat.Editor.GsplatWebpNative` 的 native fallback.
- 额外修复(让 CI/命令行也能跑测试):
  - `Runtime/GsplatSettings.cs`: 在 `SystemInfo.graphicsDeviceType==Null` 时跳过 sorter 初始化,避免 "Kernel 'InitPayload' not found" 的 error log 让测试失败.
- 回归验证(证据型):
  - Unity 6000.3.8f1 `-batchmode -nographics` 临时工程结果: `/private/tmp/gsplat_webp_test_project_02_results.xml`
  - `Gsplat.Tests.GsplatSog4DImporterTests`: passed=10, failed=0, skipped=0

### 2026-02-19 12:41:19 +0800
- 你在真实工程里重新跑了 EditMode tests 后,`.sog4d` 那 6 个原 skipped 用例已实际执行:
  - 报告文件: `/Users/cuiluming/Library/Application Support/DefaultCompany/st-dongfeng-worldmodel/TestResults.xml`
  - 汇总: total=17, passed=17, failed=0, skipped=0
- 你 Console 里看到的多条 `import error:` 日志属于预期:
  - 这些用例本来就是“导入坏数据,断言 importer 输出可操作的错误信息”.

---

# 任务计划: 修复 `GsplatSequenceDecode.compute` kernel invalid + 跑通 PLY->SOG4D->Unity 工作流

## 目标
1. 在 Unity 运行/编辑模式下,`GsplatSequenceRenderer` 不再输出 "Kernel at index (...) is invalid".
2. 给出从 PLY 序列生成 `.sog4d` 并在 Unity 播放显示的可执行步骤(含常见坑位排查).

## 阶段
- [x] 阶段1: 复现与定位(设备/API/导入产物核对)
- [x] 阶段2: 修复 decode compute shader 兼容性
- [x] 阶段3: 增加 fail-fast 检测与可操作报错
- [x] 阶段4: 工具链验证 + 文档补充

## 关键问题
1. kernel invalid 是 "kernel 缺失" 还是 "kernel 编译失败/不支持当前 Graphics API"?
2. importer 生成的数据图纹理格式(`TextureFormat.RGBA32`)是否与 compute shader 的 `Texture2DArray<uint4>` 匹配?
3. 在 `ExecuteAlways` 下,编辑模式或无图形设备时是否需要额外 guard?

## 做出的决定
- [决定] 优先把 decode compute shader 的输入改为 `Texture2DArray<float4>`,并在 shader 内把 0..1 还原为 0..255 的 `uint4`.
  - 理由: importer 生成的数据图是 `TextureFormat.RGBA32`(UNorm),跨平台最稳的读法是 float4.
  - 预期收益: 避免因 "整数视图/纹理格式不匹配" 导致 kernel 变成 invalid.

## 状态
**已完成**
时间: 2026-02-19 16:11:14 +0800.
我已定位并修复 `.sog4d` 序列播放时的 "Kernel at index (...) is invalid".
我把 decode compute shader 的数据图读取改为 `float4` + byte 还原,以匹配 importer 生成的 `TextureFormat.RGBA32`(UNorm).
同时我增加了 kernel 的 fail-fast 检测.
这样能避免 `Dispatch` 只刷 error log 的黑盒.

## 进展记录
### 2026-02-19 16:02:27 +0800
- 用户现象:
  - `GsplatSequenceDecode.compute: Kernel at index (1) is invalid`
  - 调用栈: `GsplatSequenceRenderer.TryDecodeThisFrame -> ComputeShader.Dispatch`
- 初步判断:
  - `GsplatSequenceDecode.compute` 使用 `Texture2DArray<uint4>` 读取数据图.
  - `.sog4d` importer 创建的是 `TextureFormat.RGBA32`(UNorm) 的 `Texture2DArray`.
  - 在部分 Graphics API(尤其 Metal)上,"用 uint 读 UNorm 纹理" 可能导致 kernel 编译失败,进而 dispatch 报 invalid.

### 2026-02-19 16:11:14 +0800
- 修复(根因修复 + 稳态):
  - `Runtime/Shaders/GsplatSequenceDecode.compute`:
    - 数据图读取从 `Texture2DArray<uint4>` 改为 `Texture2DArray<float4>`.
    - 增加 `Float4ToU8`,把 UNorm 的 float(0..1)还原为 byte(0..255),再按 u8/u16 规则解码.
  - `Runtime/GsplatSequenceRenderer.cs`:
    - 增加无图形设备 guard(`GraphicsDeviceType.Null`),避免 `-nographics` 刷屏.
    - 增加 `TryValidateDecodeKernel`(`GetKernelThreadGroupSizes`)做 fail-fast,避免 `Dispatch` 只刷 error log 的黑盒.
- 工具链验证(证据型):
  - `python3 Tools~/Sog4D/ply_sequence_to_sog4d.py validate --input Tests/Editor/Sog4DTestData/minimal_valid_delta_v1.sog4d.zip`
- 文档补充:
  - `README.md` 增加 "Kernel at index (...) is invalid" 的排查提示.

---

# 任务计划: 输出 `.sog4d` pack 命令手册(多配置菜谱)

## 目标
把 `Tools~/Sog4D/ply_sequence_to_sog4d.py pack` 的常用配置组合整理成一份“可复制粘贴”的命令手册.
让你在不同数据/质量/体积/速度需求下,可以直接选一条命令跑.

## 阶段
- [x] 阶段1: 梳理参数与默认值(以 `--help` 和脚本实现为准)
- [x] 阶段2: 写入文档(优先改良现有 README)
- [x] 阶段3: 用 `--help/validate` 做证据型校验
- [x] 阶段4: 收尾记录到 WORKLOG

## 做出的决定
- [决定] 不新建额外文档文件,直接扩写 `Tools~/Sog4D/README.md`.
  - 理由: "改良胜过新增". 同一入口更好找,也更不容易过期.

## 状态
**已完成**
时间: 2026-02-19 17:49:46 +0800.
我已把 pack 的常用配置整理成“命令菜谱手册”.
我把它直接扩写进 `Tools~/Sog4D/README.md`,作为唯一入口.
这样你后续只要打开这一个文件,就能按场景复制粘贴命令.

## 进展记录
### 2026-02-19 17:49:46 +0800
- 参数梳理:
  - 以 `python3 Tools~/Sog4D/ply_sequence_to_sog4d.py pack --help` 与脚本实现为准确认默认值与依赖项.
- 手册落盘:
  - 扩写 `Tools~/Sog4D/README.md`:
    - 增加依赖说明(WebP/Pillow,scipy,sklearn).
    - 增加输入数据前提(字段/帧一致性/命名排序).
    - 增加多套可复制粘贴的 pack 配置命令(菜谱).
    - 增加参数速查与 Unity 播放常见报错提示.
- 证据型校验:
  - `python3 Tools~/Sog4D/ply_sequence_to_sog4d.py validate --input Tests/Editor/Sog4DTestData/minimal_valid_delta_v1.sog4d.zip`

### 2026-02-19 17:51:13 +0800
- 追加补强:
  - `Tools~/Sog4D/README.md`: 增加 `unzip -l out.sog4d` 的 bundle 内容查看命令,并强调扩展名使用 `.sog4d`.

---

# 任务计划: 修复 Metal 下 `.sog4d` 序列 decode compute shader 编译失败(GetDimensions 不支持)

## 目标
在 macOS/Metal 下,`GsplatSequenceDecode.compute` 能正常编译与运行.
Unity Console 不再出现:
- `HLSLcc: Metal shading language does not support buffer size query from shader`
- `Kernel at index (...) is invalid`

## 阶段
- [x] 阶段1: 收集错误日志并定位根因
- [x] 阶段2: 修复 shader,移除 buffer size query
- [x] 阶段3: C# 侧传入必要的 buffer count 常量
- [ ] 阶段4: Unity 侧验证与回归

## 根因
`Runtime/Shaders/GsplatSequenceDecode.compute` 里使用了:
- `_ScaleCodebook.GetDimensions(...)`
- `_Sh0Codebook.GetDimensions(...)`
- `_ShNCentroids.GetDimensions(...)`

但 Metal 的 MSL 不支持这种 "buffer size query from shader".
因此 compute kernel 编译失败,最终导致 `Dispatch` 时 kernel invalid.

## 修复
- shader 侧:
  - 移除所有 `GetDimensions` 调用.
  - 新增 `_ScaleCodebookCount/_Sh0CodebookCount/_ShNCentroidsCount`,由 C# 侧传入.
  - shader 内只用这些 count 做 clamp 与越界防御.
- C# 侧:
  - `Runtime/GsplatSequenceRenderer.cs` 在 dispatch 前 `SetInt(...)` 传入各 buffer 的 `count`.

## 状态
**等待 Unity 验证**
时间: 2026-02-19 17:54:42 +0800.
修复已落盘.
我需要你在 Unity 里重新触发一次脚本/compute shader 重新编译(通常自动发生).
然后确认不再出现 Metal 的 GetDimensions 编译错误.

## 进展记录
### 2026-02-19 17:54:42 +0800
- 用户日志(关键错误):
  - `Shader error in 'GsplatSequenceDecode': HLSLcc: Metal shading language does not support buffer size query from shader. Pass the size to shader as const instead.`
  - kernel: `DecodeKeyframesSH0/DecodeKeyframesSH`
- 代码修复已完成:
  - `Runtime/Shaders/GsplatSequenceDecode.compute`: 移除 `GetDimensions`,改用 C# 传入的 count.
  - `Runtime/GsplatSequenceRenderer.cs`: dispatch 前传入 `_ScaleCodebookCount/_Sh0CodebookCount/_ShNCentroidsCount`.

---

# 任务计划: continuous-learning 提取 Unity/Metal compute 排障 skill

## 目标
把本次 Unity/macOS/Metal 下 compute shader 的排障经验固化成可复用知识:
- `Kernel at index (...) is invalid` 的真实含义与 fail-fast 检测方式.
- Metal 不支持 `StructuredBuffer.GetDimensions`(buffer size query)的规避写法.
- RGBA8 UNorm 数据图纹理在 shader 内的更稳读取方式(`float4` + byte 还原).

## 阶段
- [x] 阶段1: 回读四文件并做摘要
- [x] 阶段2: 去重并补齐参考资料
- [x] 阶段3: 创建/更新 skill
- [x] 阶段4: 同步 AGENTS.md 与四文件记录

## 状态
**已完成**
时间: 2026-02-19 18:53:37 +0800.
我已完成 continuous-learning 复盘:
- 新增 skill: `~/.codex/skills/self-learning.unity-metal-compute-kernel-invalid/SKILL.md`
- 更新项目协作约定: `AGENTS.md` 增加 Metal compute 注意事项,避免未来回归.

---

# 任务计划: 修复 decode kernel 验证误判(避免 `GetKernelThreadGroupSizes` 误报阻塞播放)

## 目标
在 macOS/Metal 下,`.sog4d` 序列播放不再因为 kernel 验证阶段的误判而被禁用.
典型现象包括:
- `IndexOutOfRangeException: Invalid kernelIndex ...` 出现在 `ComputeShader.GetKernelThreadGroupSizes`.
- 但 shader 侧没有新的编译 error,播放仍被阻塞.

## 阶段
- [x] 阶段1: 收集用户日志并定位触发点
- [x] 阶段2: 调整验证策略(只验证需要的 kernel)
- [x] 阶段3: `GetKernelThreadGroupSizes` 降级为非强制检查
- [ ] 阶段4: Unity 侧验证与回归

## 修复摘要
- `Runtime/GsplatSequenceRenderer.cs`:
  - 当 `shBands>0` 时只验证 `DecodeKeyframesSH`,不再因为 `DecodeKeyframesSH0` 的反射异常阻塞播放.
  - 先用 `ComputeShader.IsSupported` 做能力探测.
  - `GetKernelThreadGroupSizes` 抛 `IndexOutOfRangeException` 时降级为 warning,继续尝试运行.
  - decode 失败不再导致 Update 每帧重建 renderer 刷屏,并在 asset 变化时先 `DisposeDecodeResources`.

## 状态
**等待 Unity 验证**
时间: 2026-02-19 19:12:31 +0800.
请在 Unity 中清空 Console 后重新启用对象,确认不再出现:
- `[Gsplat][Sequence] DecodeComputeShader kernel 无效: ...`
- `Invalid kernelIndex ... GetKernelThreadGroupSizes ...`

---

# 任务计划: `gaussian_pertimestamp` 输出高质量 `.sog4d`

## 目标
把 `/Users/cuiluming/local_doc/l_dev/my/unity/gaussian_pertimestamp` 下的 `time_*.ply` 序列,
打包生成一个“质量优先”的 `.sog4d`,
用于 Unity 中通过 `GsplatSequenceRenderer` 播放显示.

## 阶段
- [x] 阶段1: 输入确认与约束核对
- [x] 阶段2: 选择打包配置(质量/体积/速度权衡)
- [x] 阶段3: 执行 `pack` + `validate`(self-check)
- [ ] 阶段4: Unity 导入与播放验证(回归)

## 关键问题
1. 输入 PLY 的 `opacity/scale` 语义是什么(是否需要 sigmoid/exp)?
2. “高质量”的定义更偏向:
   - 更大 codebook/palette(量化误差更小)?
   - 更高 SH(bands=3)?
   - 还是仅在保证可播的前提下尽量压缩体积?

## 做出的决定
- [决定] 采用“质量优先”配置作为默认输出,同时保留一条“先能用”的平衡配置备选.
  - 理由: 你明确要求输出高质量 `.sog4d`,并且该序列帧数只有 20,做高质量拟合的成本可控.

## 状态
**目前在阶段4(等待 Unity 验证)**
时间: 2026-02-19 20:13:39 +0800.
我已生成并验证“质量优先”的 `.sog4d` 输出.
下一步是在 Unity 中导入并播放,确认不再出现 Metal/ComputeShader 相关报错.

## 进展记录
### 2026-02-19 19:14:49 +0800
- 输入确认(阶段1):
  - 输入目录: `/Users/cuiluming/local_doc/l_dev/my/unity/gaussian_pertimestamp`
  - PLY 文件: `time_00000.ply`..`time_00019.ply`(共 20 帧)
  - splatCount: 27673
  - 检测到 `f_rest_0..44`(45 个标量),因此 `shBands=3`
  - `opacity` 为 logit(范围约 [-8,9]),因此需要 `sigmoid`
  - `scale_0/1/2` 为 log(scale)(大量负数),因此需要 `exp`

- 配置选择(阶段2):
  - 质量优先(默认执行):
    - `--opacity-mode sigmoid --scale-mode exp`
    - `--sh-bands 3`
    - `--scale-codebook-size 8192 --scale-sample-count 400000`
    - `--sh0-codebook-method kmeans --sh0-sample-count 4000000`
    - `--shN-count 8192 --shN-sample-count 400000 --shN-centroids-type f32`
    - `--shN-labels-encoding delta-v1 --delta-segment-length 50`
    - `--zip-compression deflated --self-check`
  - 平衡配置(备选,更快更省内存,但量化误差更大):
    - 基本保持默认参数,只强制 `--sh-bands 3` + `--self-check`

### 2026-02-19 20:13:39 +0800
- 输出文件(阶段3):
  - `/Users/cuiluming/local_doc/l_dev/my/unity/gaussian_pertimestamp/gaussian_pertimestamp_quality_sh3.sog4d`
  - meta.json 关键字段:
    - `frameCount=20`
    - `layout=167x166`
    - `shNCount=8192`
    - `shNCentroidsType=f32`
    - `shNLabelsEncoding=delta-v1`
- 自检/校验(阶段3):
  - `python3 Tools~/Sog4D/ply_sequence_to_sog4d.py validate --input /Users/cuiluming/local_doc/l_dev/my/unity/gaussian_pertimestamp/gaussian_pertimestamp_quality_sh3.sog4d`
  - 输出: `[sog4d] validate ok (delta-v1).`
- 下一步(阶段4):
  - 导入 Unity 并挂 `GsplatSequenceRenderer` 播放.
  - 重点确认 Console 不再出现:
    - `Kernel at index (...) is invalid`
    - `HLSLcc: Metal shading language does not support buffer size query from shader`

---

# 任务计划: 多档质量输出 `gaussian_pertimestamp` `.sog4d`(pack 脚本稳态验证)

## 目标
从同一套输入 PLY 序列输出多份不同质量/体积/复杂度的 `.sog4d`,
并对每一份输出执行 `validate`,
用“证据型”结果确认 `pack` 脚本在多配置下都没有隐藏问题.

## 阶段
- [x] 阶段1: 选定输出矩阵与命名
- [x] 阶段2: 执行 `pack` 生成多份 `.sog4d`
- [x] 阶段3: 对每份输出执行 `validate` + 记录文件尺寸
- [x] 阶段4: 汇总到四文件 + 给出 Unity 导入验证建议

## 输出矩阵(计划)
输入:
- `/Users/cuiluming/local_doc/l_dev/my/unity/gaussian_pertimestamp/time_*.ply`

计划输出(会逐个 pack + validate):
1. SH0-only(最快,先跑通最小路径):
   - `gaussian_pertimestamp_fast_sh0.sog4d`
2. SH3 默认(平衡,覆盖默认分支):
   - `gaussian_pertimestamp_balanced_sh3_delta_f16.sog4d`
3. SH3 体积优先(更小 palette,更容易暴露越界/边界 bug):
   - `gaussian_pertimestamp_small_sh3_delta_f16_4096.sog4d`
4. SH3 质量优先(已完成):
   - `gaussian_pertimestamp_quality_sh3.sog4d`

## 状态
**已完成**
时间: 2026-02-19 21:14:10 +0800.
我已完成多配置输出与逐一 validate 自检,并已把结果汇总回四文件.
接下来只需要在 Unity 里按建议导入其中任意一个 `.sog4d` 做端到端播放验证即可.

## 进展记录
### 2026-02-19 21:12:30 +0800
- 输出目录(避免把输出混在 input-dir 里):
  - `/Users/cuiluming/local_doc/l_dev/my/unity/gaussian_pertimestamp_out`
- 已生成并自检通过(`--self-check`):
  1. SH0-only(最小路径,最快):
     - `gaussian_pertimestamp_out/gaussian_pertimestamp_fast_sh0.sog4d`
     - `validate ok (bands=0)`, size=7.3MiB
  2. SH3 + delta-v1(多 segment,覆盖边界逻辑):
     - `gaussian_pertimestamp_out/gaussian_pertimestamp_balanced_sh3_delta_seg5_shN4096_f16.sog4d`
     - `validate ok (delta-v1)`, size=7.8MiB
     - meta: `shNCount=4096`, `shNCentroidsType=f16`,并且 `shNDeltaSegments` 存在多段(由 `--delta-segment-length 5` 产生)
  3. SH3 + full labels(覆盖 full 路径):
     - `gaussian_pertimestamp_out/gaussian_pertimestamp_balanced_sh3_full_shN8192_f16.sog4d`
     - `validate ok (full labels)`, size=8.7MiB
     - meta: `shNCount=8192`, `shNCentroidsType=f16`, `shNLabelsEncoding=full`

- 已有的质量优先(参考对照,更大采样量 + f32 centroids + ZIP deflated):
  - `/Users/cuiluming/local_doc/l_dev/my/unity/gaussian_pertimestamp_quality_sh3.sog4d`
  - 同时已复制到输出目录:
    - `gaussian_pertimestamp_out/gaussian_pertimestamp_quality_sh3.sog4d`
  - `validate ok (delta-v1)`, size=8.3MiB

---

# 任务计划: 输出 `.sog4d` 详细准确规格(用于 FreeTimeGsVanilla 改版导出器)

## 目标
输出一份可以直接用来实现 exporter 的 `.sog4d` 文件格式规格.
重点是: 结构清晰,字段类型准确,二进制布局不含糊.

## 阶段
- [x] 阶段1: 回读现有 specs/实现(Importer + Tools)
- [x] 阶段2: 对齐 v1/v2 与 delta-v1 的真实细节
- [x] 阶段3: 产出对外可用的规格说明(回复 + 可选落盘文档)
- [x] 阶段4: 四文件收尾(WORKLOG/notes/LATER_PLANS)

## 关键问题
1. `.sog4d` 的容器与 `meta.json` schema 的强约束有哪些(哪些必须 fail-fast).
2. delta-v1 的二进制布局里 update entry 是否包含 reserved 字段(需要按实现对齐).
3. v2 的 SH rest 按 band 拆分(sh1/sh2/sh3)对 exporter 的影响是什么.

## 做出的决定
- [决定] 以当前仓库实现为准来输出规格:
  - `Editor/GsplatSog4DImporter.cs` 代表 Unity 侧"读者"的真实期望.
  - `Tools~/Sog4D/ply_sequence_to_sog4d.py` 代表一份可运行的"写者"参考实现.
  - 如发现 OpenSpec 文档与实现不一致,以实现为准,并在回复中明确指出差异.

## 状态
**已完成**
- 时间: 2026-02-21
- 我已输出 `.sog4d` 的统一规格说明,并完成四文件收尾.

## 进展记录
### 2026-02-21 15:34:59 +0800
- 已完成回读与对齐:
  - 以 `Editor/GsplatSog4DImporter.cs` 与 `Tools~/Sog4D/ply_sequence_to_sog4d.py` 为准核对所有字段与二进制布局.
  - 已更新 `openspec/specs/sog4d-sequence-encoding/spec.md`:
    - 补齐 `meta.json.version=2` 的 sh1/sh2/sh3 per-band 编码.
    - 补齐 delta-v1 的 update entry: `(splatId u32, newLabel u16, reserved u16=0)`,并要求 block 内 splatId 严格递增.
  - `openspec validate --specs --strict` 已通过.
- 下一步:
  - 输出 `.sog4d` 的统一规格说明(用于 FreeTimeGsVanilla 改版 exporter).
  - 然后完成四文件收尾.

### 2026-02-21 15:38:10 +0800
- 已输出统一规格说明到对话(用于实现 exporter).
- 已完成四文件收尾:
  - `task_plan.md`/`notes.md`/`WORKLOG.md`/`LATER_PLANS.md` 均已追加本次任务记录.

---

# 任务计划: 修复 FreeTimeGsVanilla 输出 `.sog4d` 导入失败 + 改良 `.splat4d` 默认 VFX 资产查找

## 目标
1. 让 FreeTimeGsVanilla 导出的 `.sog4d` 能在本包 Unity importer 中成功导入并播放.
2. 当用户已导入 `Samples~/VFXGraphSample` 时,`.splat4d` 一键导入能自动找到 `SplatSorted.vfx`/`Splat.vfx`,减少误导性 warning.

## 现象
- Unity Console 出现 warning:
  - `[Gsplat][VFX] 未找到默认 VFX Graph asset: Packages/wu.yize.gsplat/Samples~/VFXGraphSample/VFX/SplatSorted.vfx 或 Packages/wu.yize.gsplat/Samples~/VFXGraphSample/VFX/Splat.vfx ...`
  - 堆栈: `Gsplat.Editor.GsplatSplat4DImporter:OnImportAsset`(约 `Editor/GsplatSplat4DImporter.cs:449`)
- 对 FreeTimeGsVanilla 的 `.sog4d` 做离线自检时失败:
  - `python3 Tools~/Sog4D/ply_sequence_to_sog4d.py validate --input <file>.sog4d`
  - 输出: `[sog4d][error] meta.json.format 非法: None`
- 进一步检查 `.sog4d` 内的 `meta.json`:
  - 缺少顶层字段 `"format": "sog4d"`
  - `streams.position.rangeMin/rangeMax` 与 `streams.scale.codebook` 使用 `[[x,y,z]]` 形式,与 Unity `JsonUtility` 期望的 `{x,y,z}` 不一致.

## 方向(二选一)
- 方向A(推荐,最佳): 兼容与修复并行.
  - 在 importer/runtime 的 ZIP entry map 中对同名条目采用“保留最后一个”(更符合 zip update 语义).
  - 在离线工具中提供一个“规范化 meta.json”的命令,把 legacy `.sog4d` 一键修到符合本包 spec.
  - 优点: 不必重新导出巨大的 `.sog4d`,可快速救火.
- 方向B(先能用): 只修 exporter 并要求重新导出.
  - 让 FreeTimeGsVanilla exporter 输出完全符合 spec 的 meta.json.
  - 优点: 规范更干净; 缺点: 对大文件需要重新导出,成本高.

## 阶段
- [x] 阶段1: 证据与复现落盘
- [x] 阶段2: 修复 `.sog4d` ZIP 同名 entry 策略(保留最后一个)
- [x] 阶段3: 增加 `.sog4d` meta.json 规范化工具
- [x] 阶段4: 改良 `.splat4d` 默认 VFX 资产查找(支持 `Assets/Samples/...`)
- [ ] 阶段5: 验证 + 四文件收尾(ERRORFIX/WORKLOG/LATER_PLANS 回溯清理)

## 状态
**目前在阶段5(等待 Unity 验证)**
- 时间: 2026-02-22 15:20:43 +0800
- 已完成:
  - `.sog4d` importer/runtime: ZIP 同名条目改为“取最后一个”,符合 zip update 语义.
  - 离线工具新增 `normalize-meta`,可一键补 `meta.format` 并规范化 Vector3 JSON.
  - `.splat4d` importer: 增加在 `Assets/Samples/**/VFX/` 下搜索默认 `.vfx` 的回退逻辑.
- 已做离线验证:
  - `normalize-meta` 在真实 `.sog4d` 上执行后 `validate ok`.
- 待 Unity 侧确认:
  - 重新导入该 `.sog4d` 后不再报 meta.json 错误,并能正常播放.
  - 在已导入 sample 的项目里导入 `.splat4d` 不再报“未找到默认 VFX Graph asset”,并能自动挂 VFX 组件.

---

# 任务计划: 修复 HDRP/SceneView 下 Gsplat 排序与刷新不同步

## 目标
在 Unity 编辑器的 SceneView(隐藏相机)观察 Gsplat 时:
1. 相机强烈旋转(尤其转到背后)时,高斯基元显示正确(排序正确).
2. 拖动 `GsplatRenderer.TimeNormalized` 时,SceneView 立即同步更新,不需要切换到 GameView 再切回来“刷新”.
3. HDRP/URP 不再强依赖额外的手动注入配置(HDRP 的 CustomPassVolume,URP 的 RendererFeature).
4. Play 模式下避免无意义的“双相机双排序”性能损耗,但在你聚焦 SceneView 交互时仍保证正确性.

## 现象
- SceneView 相机强旋转/转到背后时,Gaussians 显示不正确,看起来像没有 sort.
- 在编辑态拖动 `TimeNormalized` 时,SceneView 画面会“乱飞/不稳定”.
  - 切到 GameView 再切回 SceneView 后,画面恢复正确.

## 根因(已验证)
1. HDRP/URP 的排序触发点此前依赖“管线注入点”(HDRP CustomPass/URP Feature),SceneView 相机并非必然覆盖,导致 `_OrderBuffer` 过期.
2. 编辑态拖动 `TimeNormalized` 时,SceneView 不一定立刻 Repaint,导致你必须“切到 GameView 再切回来”才能看到一次同步后的结果.

## 方向(二选一)
- 方向A(推荐,最佳): SRP 通用相机回调驱动排序.
  - 用 `RenderPipelineManager.beginCameraRendering` 在每个 SRP 相机开始渲染时触发 sort.
  - HDRP/URP 的旧注入点保留但自动跳过,避免重复 sort.
- 方向B(先能用): 继续依赖 HDRP CustomPassVolume,并要求项目配置覆盖 SceneView.
  - 缺点: 配置依赖强,容易再次被项目设置/场景变化击穿.

## 阶段
- [x] 阶段1: 证据收集与代码定位
- [x] 阶段2: SRP(beginCameraRendering) 驱动排序
- [x] 阶段3: 旧注入点互斥(避免重复排序)
- [x] 阶段4: Play 模式 SceneView “聚焦才排序”智能策略
- [x] 阶段5: 编辑态拖动 TimeNormalized 立刻刷新(SceneView Repaint)
- [x] 阶段6: 文档与版本更新(Setup 不再强依赖配置)
- [x] 阶段7: 验证 + 四文件收尾(WORKLOG/ERRORFIX/LATER_PLANS)

## 做出的决定
- [决定] 选择方向A: SRP 通用相机回调驱动排序.
  - 理由: SceneView 相机属于隐藏相机,依赖 HDRP CustomPassVolume 覆盖它不稳定,且对使用者不友好.
- [决定] Play 模式默认仍跳过 SceneView 排序,但允许在 SceneView 聚焦时临时启用排序.
  - 理由: 兼顾“编辑体验正确性”和“Play 模式性能”.

## 状态
**已完成**
- 时间: 2026-02-23
- 已完成代码改动与文档更新,并已追加 `WORKLOG.md/ERRORFIX.md/LATER_PLANS.md` 收尾记录.

---

# 任务计划: ActiveCameraOnly 单相机排序/渲染(多相机性能优化 + 编辑器焦点切换)

## 目标
1. 当场景里存在很多相机(反射/探针/多视口等)时,每帧对 Gsplat 的 GPU sort 次数控制为 1 次(只对 ActiveCamera).
2. Unity 编辑器非 Play 模式下:
   - 聚焦 "场景(SceneView)" 时,ActiveCamera 固定为 SceneView 相机.
   - 聚焦 "游戏(GameView)" 时,ActiveCamera 固定为 Main Camera(或自动选出的 Game 相机).
3. Unity 编辑器 Play 模式下:
   - ActiveCamera 始终为 Game/VR 相机(不因 SceneView 焦点切换),优先保证 GameView 体验.
4. 当场景只有 1 个 Main Camera 时:
   - 默认自动选它作为 ActiveCamera(但在 SceneView 观察时仍以 SceneView 相机为准).

## 背景/现象
- 典型数据规模: >1M 且 <10M.
- SRP 下排序入口现在统一走 `RenderPipelineManager.beginCameraRendering`.
  - 好处: SceneView 隐藏相机也能稳定触发排序,显示正确.
  - 代价: 场景里每多一个相机,同一帧内就可能多触发一次 sort,性能会线性恶化.

## 方向(二选一)
- 方向A(推荐,最佳): 引入 "ActiveCameraOnly" 模式.
  - 只对 ActiveCamera 做 sort,也只对 ActiveCamera 提交 draw call.
  - 把“多相机 N 次 sort”直接压成“每帧最多 1 次 sort”.
- 方向B(先能用): 保持 AllCameras 行为,主要靠用户减少相机数量/关掉不必要相机.
  - 缺点: 工程上不可控,也不符合“系统应该帮用户兜底”的原则.

## 阶段
- [x] 阶段1: 制作 OpenSpec change(把方案固化为 proposal/design/tasks/specs)
- [x] 阶段2: 实现 ActiveCamera 选择与缓存(Play/非Play/SceneView/GameView)
- [x] 阶段3: sorter/render 门禁 + 回归测试(保证只对 ActiveCamera 生效)
- [x] 阶段4: 文档同步 + validate + 四文件收尾

## 做出的决定
- [决定] 默认开启 "ActiveCameraOnly" 性能模式.
  - 理由: 在 >1M splats 规模下,多相机重复排序的成本远高于“所有相机都能看到 Gsplat”的兼容价值.
- [决定] 多个 Game/VR 相机且未显式指定时,优先 `Camera.main`.
  - 理由: 这是 Unity 生态里最常见的“主视角”约定,用户心智一致.
- [决定] Editor Play 模式不因 SceneView 聚焦切换 ActiveCamera,始终保证 GameView.
  - 理由: Play 模式下用户通常在调试实际游戏视角,SceneView 只作为辅助,不应拉低主视角性能.
- [决定] Editor 非 Play 模式按窗口焦点切换(SceneView vs GameView).
  - 理由: 符合编辑器直觉: 你正在看哪个窗口,就保证哪个窗口正确.

## 状态
**已完成**
- 时间: 2026-02-23 18:59:21 +0800

## 进展记录
### 2026-02-23
- 已创建 OpenSpec change:
  - `openspec/changes/active-camera-only/`
- 已完成 artifacts:
  - `proposal.md` / `design.md` / `specs/gsplat-camera-selection/spec.md` / `tasks.md`
- 已做严格校验(证据型):
  - `openspec validate active-camera-only --type change --strict`
  - `openspec validate --all --strict`

### 2026-02-23 18:53:24 +0800
- 已完成阶段2/3(代码落地 + 回归测试):
  - `Runtime/GsplatSorter.cs`:
    - 修复 batchmode 下 `Time.frameCount` 不稳定导致的缓存问题:
      - batchmode 下禁用“按帧缓存”
      - 避免命中 `null` 缓存导致后续一直返回 false
    - 修复 `-batchmode -nographics` 下相机枚举失败:
      - 当 `Camera.allCamerasCount==0` 时,用 FindObjects 系列做一次兜底枚举
      - 避免 ActiveCameraOnly 下“无法解析 ActiveCamera -> 直接不渲染”的灾难性退化
  - `Tests/Editor/GsplatActiveCameraOnlyTests.cs`:
    - `SetUp` 时创建 `EmptyScene`,避免项目默认场景的 `Main Camera` 污染用例假设
- 证据型验证(Unity batchmode -nographics):
  - `-testFilter Gsplat.Tests.GsplatActiveCameraOnlyTests`: passed(4/4)
  - `-testFilter Gsplat.Tests`: passed(21), skipped(1), failed(0)
- 下一步进入阶段4:
  - 更新 `README.md` / `Documentation~/Implementation Details.md` / `CHANGELOG.md` / `package.json`
  - 更新 `openspec/changes/active-camera-only/tasks.md` 勾选完成项,并重新 `openspec validate --strict`
  - 四文件收尾: `notes.md` / `WORKLOG.md` / `LATER_PLANS.md` / `ERRORFIX.md`

### 2026-02-23 18:59:21 +0800
- 已完成阶段4(文档 + validate + 四文件收尾):
  - 文档与版本:
    - `README.md`: 增加 `CameraMode` 说明与默认行为提示.
    - `Documentation~/Implementation Details.md`: 补充 ActiveCameraOnly 下 sort/render 的门禁规则.
    - `CHANGELOG.md`: 新增 `1.1.4`,并 bump `package.json` 到 `1.1.4`.
  - OpenSpec 严格校验:
    - `openspec validate active-camera-only --type change --strict`: passed
    - `openspec validate --all --strict`: 9 passed, 0 failed
  - 四文件收尾:
    - `notes.md` / `WORKLOG.md` / `ERRORFIX.md` / `LATER_PLANS.md`: 已追加本次任务的结论与验证证据.

---

# 任务计划: 修复 Editor UI 交互导致 Gsplat 闪烁(ActiveCameraOnly EditMode)

## 目标
在 Editor 非 Play 模式下:
- 当我在 Inspector/Hierarchy 等 UI 中交互时,SceneView 中的 Gsplat 不再出现“显示/不显示”闪烁.

## 阶段
- [x] 阶段1: 复盘最近改动与可能触发点
- [x] 阶段2: 定位根因(ActiveCamera 选择策略)
- [x] 阶段3: 修复与回归验证
- [x] 阶段4: OpenSpec/文档同步 + 四文件收尾

## 根因(结论)
- `CameraMode=ActiveCameraOnly` 后,渲染被门禁到 ActiveCamera.
- 旧的 EditMode 策略是:
  - SceneView 聚焦才选 SceneView 相机.
  - Inspector/Hierarchy 聚焦时沿用上一帧缓存.
- 当用户在 Editor UI 中交互时,焦点变化会导致 ActiveCamera 在 SceneView/GameView 之间切换,
  从而出现 SceneView 中“渲染目标相机不是 SceneView 相机”的情况,最终表现为整体闪烁.

## 修复(结论)
- EditMode 下改为更稳态的策略:
  - 只有当 GameView 聚焦时,才选择 Game/VR 相机.
  - 否则只要 SceneView 存在,就优先选择 SceneView 相机(不要求 hasFocus).
  - 若环境不存在 SceneView(例如 batchmode),再兜底为上一帧或 Game/VR 相机规则.

## 状态
**已完成**
- 时间: 2026-02-23 19:34:58 +0800

## 进展记录
### 2026-02-23 19:34:58 +0800
- 已修改 ActiveCamera 解析:
  - `Runtime/GsplatSorter.cs`:
    - 新增 `TryGetAnySceneViewCamera`(不要求 hasFocus).
    - EditMode 下默认优先 SceneView,仅 GameView 聚焦时切到 Game/VR.
- 文档与 OpenSpec 同步:
  - `README.md` / `Documentation~/Implementation Details.md`: 更新 EditMode 相机规则描述.
  - `openspec/changes/active-camera-only/design.md`/`specs/gsplat-camera-selection/spec.md`: 同步“EditMode 默认 SceneView”契约.
  - `CHANGELOG.md`: 补充本修复的用户可见说明.
- 证据型验证:
  - `openspec validate --all --strict`: 9 passed, 0 failed
  - Unity batchmode tests 未回归:
    - `Gsplat.Tests.GsplatActiveCameraOnlyTests`: passed(4/4)
    - `Gsplat.Tests`: passed(21), skipped(1), failed(0)

---

# 任务计划: 修复 ActiveCameraOnly 下 Editor UI 交互仍闪烁(焦点信号不可靠)

## 目标
在 Editor 非 Play 模式下:
- 当我在 Inspector/Hierarchy 等 UI 中交互时,当前我正在看的视口(SceneView 或 GameView)保持稳定显示.
- 避免因为 window focus 抖动,导致 ActiveCamera 在 SceneView/GameView 间来回切换,
  从而出现 Gsplat “显示/不显示”的闪烁.

## 现象(用户反馈)
- `CameraMode=ActiveCameraOnly` 时,与 Editor UI 交互会导致 Gsplat 不停闪烁.
- 切到 `CameraMode=AllCameras` 时不闪烁.

## 根因(待验证)
- EditMode 下当前使用 `UnityEditor.EditorWindow.focusedWindow` 判断 GameView 是否聚焦.
- 但在拖动 Inspector 控件、与 UI 交互等场景中,`focusedWindow` 可能仍停留在 GameView,
  或者在多个窗口之间抖动.
- ActiveCamera 因此在 SceneView/GameView 之间切换,而 ActiveCameraOnly 又只对 ActiveCamera 渲染,
  最终表现为视口内整体“显示/不显示”闪烁.

## 方案(预案)
- 引入更稳态的“视口 hint”缓存:
  - 只在 `mouseOverWindow` 或 `focusedWindow` 明确是 SceneView/GameView 时,才更新 hint.
  - 在 Inspector/Hierarchy 等非视口窗口交互时,沿用上一帧的 hint,不切换 ActiveCamera.
  - 若从未得到 hint,且 SceneView 存在则默认 SceneView.

## 阶段
- [x] 阶段1: 增加最小诊断日志(仅 ActiveCamera 变化时输出)
- [x] 阶段2: 实现视口 hint 缓存与选择规则调整(`Runtime/GsplatSorter.cs`)
- [x] 阶段3: 文档 + OpenSpec 同步
- [ ] 阶段4: Unity 手动验证 + 四文件收尾(ERRORFIX/WORKLOG/notes/LATER_PLANS 回溯)

## 状态
**目前在阶段4(等待 Unity 手动验证)**
- 时间: 2026-02-23
- 已完成:
  - `Runtime/GsplatSorter.cs`: EditMode 下用“视口 hint”(mouseOverWindow + 缓存)稳定 ActiveCamera,避免 UI 交互时抖动.
  - Unity 回归(EditMode tests,通过 Unity MCP): `Gsplat.Tests.Editor` passed=22, failed=0, skipped=0.
  - 文档同步: `README.md` / `Documentation~/Implementation Details.md` / `CHANGELOG.md`.
  - OpenSpec 同步: `openspec/changes/active-camera-only/design.md` / `openspec/changes/active-camera-only/specs/gsplat-camera-selection/spec.md` / `openspec/changes/active-camera-only/tasks.md`.
- 待验证:
  - Unity Editor EditMode 下,`CameraMode=ActiveCameraOnly` 时在 Inspector/Hierarchy 交互不再闪烁.

### 2026-02-24 00:13:39 +0800
- 用户反馈: 仍会复现闪烁
  - 复现: 转动/移动 SceneView 视角时,鼠标在 UI 上划过,SceneView 内 Gsplat 仍会“显示/不显示”闪烁.
  - 结论: 现有 viewport hint 缓存 + SceneView transform 运动锁定,仍不足以覆盖某些 Editor 交互(怀疑 mouseOverWindow==null / focus 抖动 / SceneView 相机 transform 更新时间点).
- 下一步(继续阶段4,补充修复后再验证):
  - 引入更可靠的“SceneView 交互锁定”信号: 监听 `SceneView.duringSceneGui`,在发生鼠标拖拽/滚轮/按键导航时记录时间戳,在短时间内强制 hint=SceneView.
  - 把 `mouseOverWindow==null` 视为“歧义状态”,优先沿用上一帧 hint,避免因为 focusWindow 抖动导致 hint 被错误切到 GameView.
  - 目标: 只要用户刚刚在 SceneView 交互(尤其是旋转视角),就不允许 ActiveCameraOnly 在 UI 交互过程中切走 ActiveCamera.

### 2026-02-24 02:11:10 +0800
- 用户反馈补充:
  - 仍然闪烁,并且 GameView 里也会出现“突然不显示/又出现”的现象.
  - Console warning(Metal):
    - `Gsplat/Standard` 的 Vertex/Fragment shader 需要绑定 ComputeBuffer(index=3),但实际没有绑定,因此 Unity 为避免崩溃跳过 draw call.
- 初步判断(两条线并行):
  1) ActiveCameraOnly(EditMode) 的渲染门禁在某些交互链路下仍可能把 draw 提交到“不是当前正在渲染的那个相机实例”,导致视口内整体消失/闪烁.
  2) Metal 的 buffer 未绑定 warning 会直接导致跳绘制,这会让 GameView/SceneView 都出现“偶发消失”,并把问题伪装成相机切换闪烁.
- 下一步(继续阶段4):
  - 让 EditMode 的 draw 目标跟随 ActiveCamera 解析结果:
    - ActiveCamera=SceneView 时: 对所有 SceneView 相机提交 draw(规避相机实例抖动).
    - ActiveCamera=Game/VR 时: 只对 ActiveCamera 提交 draw(保证 GameView 稳定).
  - 强化 buffer 绑定稳态:
    - 每次 Render 前重新绑定所有 StructuredBuffers,避免 MaterialPropertyBlock 的 buffer 绑定被后续 SetXXX 覆盖导致 Metal 跳绘制.
    - 统一把 4D buffers(dummy 也算)视为 shader 的必需资源,避免 “Has4D=false 时不检查 -> 某些路径漏绑” 的隐患.
  - 增加一个轻量的“指定 ActiveCamera”组件,让你可以直接指定某个 Camera,不再依赖 Editor 焦点/鼠标窗口信号.

### 2026-02-24 06:18:43 +0800
- 已按上面预案落地修复(代码 + 文档 + 校验):
  - Metal 稳态:
    - `Runtime/GsplatRendererImpl.cs` 每次 draw 前重新绑定所有 StructuredBuffers,并把 4D buffers(dummy)视为必需绑定.
  - EditMode 渲染目标稳态:
    - ActiveCamera=SceneView: 对所有 SceneView cameras 提交 draw(规避内部相机实例抖动).
    - ActiveCamera=Game/VR: 只对 ActiveCamera 提交 draw.
  - EditMode 视口 hint 稳态补强:
    - `SceneView.duringSceneGui` 增加 MouseMove 锁定,鼠标在 SceneView UI 上滑动时也稳定 hint=SceneView.
    - 鼠标悬停在 SceneView 时,不再要求 `over==focused`,直接更新 hint=SceneView.
  - 新增“指定相机”组件:
    - `Runtime/GsplatActiveCameraOverride.cs`(Priority + last-enabled tie-break).
- 证据型验证:
  - OpenSpec:
    - `openspec validate --all --strict`: 9 passed, 0 failed
  - Unity 命令行(独立最小工程,避免主项目被 Unity 锁):
    - project: `/Users/cuiluming/local_doc/l_dev/my/unity/_tmp_gsplat_pkgtests`
    - `Gsplat.Tests`(EditMode): total=22, passed=21, failed=0, skipped=1
- 待你在 Unity Editor 手动复现验证:
  - EditMode 下,鼠标在 SceneView UI 上滑动/旋转视角/操作 Inspector,不应再出现整体“显示/不显示”闪烁.
  - Metal warning 不应再出现(若仍出现,需要进一步定位具体缺失的是哪个 buffer slot).

### 2026-02-24 06:22:32 +0800
- 为了让“指定相机 override 组件”可回归,新增了一个 EditMode tests:
  - `Tests/Editor/GsplatActiveCameraOverrideComponentTests.cs`
- 并重新跑最小工程的 `Gsplat.Tests`(EditMode):
  - total=25, passed=24, failed=0, skipped=1

### 2026-02-24
- 用户反馈: 鼠标滑动在 "场景(SceneView)" 窗口的 UI 上,仍然会闪烁.
- 推断(更聚焦到 Editor 信号层面的根因):
  - `EditorWindow.mouseOverWindow` 在 SceneView 的部分 UI(尤其是 overlay/UIElements 区域)里可能返回 `null` 或返回“非 SceneView 的内部窗口”.
  - 我们当前在 `mouseOverWindow==null` 时会优先沿用缓存 hint.
  - 如果缓存 hint 恰好是 GameView,ActiveCameraOnly 会把渲染切到 Game/VR,导致 SceneView 侧整体“显示/不显示”.
- 下一步(继续阶段4,补强稳态后再验证):
  - 在 `Runtime/GsplatSorter.cs`:
    - 增加对 `UnityEditor.SceneView.mouseOverWindow`(如存在)的反射读取,作为 `EditorWindow.mouseOverWindow` 的强补充信号.
    - 调整 `mouseOverWindow==null` 的处理顺序: 先尝试用 SceneView 的 mouseOver 信号判定是否在 SceneView,再决定是否沿用缓存.
  - 在 `Runtime/GsplatRendererImpl.cs`:
    - EditMode + ActiveCamera=SceneView 时,渲染目标相机改为直接遍历 `SceneView.sceneViews` 的 cameras,
      避免 `Camera.GetAllCameras` 在 Editor 下拿不到隐藏 SceneView camera 时退化回“只画某一个实例”,从而引入闪烁风险.

### 2026-02-24
- 已按上面预案继续补强稳态:
  - `Runtime/GsplatSorter.cs`:
    - 通过反射可选读取 `UnityEditor.SceneView.mouseOverWindow`(若存在),作为 `EditorWindow.mouseOverWindow` 的补强信号.
    - 调整 `mouseOverWindow==null` 的处理顺序:
      - 先尝试用 SceneView 的 mouseOver 信号判定是否在 SceneView.
      - 再决定是否沿用缓存 hint.
  - `Runtime/GsplatRendererImpl.cs`:
    - EditMode + ActiveCamera=SceneView 时,改为遍历 `UnityEditor.SceneView.sceneViews` 的 cameras 提交 draw.
      - 目的: 避免 Editor 隐藏 SceneView camera 不在 `Camera.GetAllCameras` 枚举里时产生的闪烁.
- 证据型验证(Unity 命令行,最小工程 `_tmp_gsplat_pkgtests`):
  - `Gsplat.Tests`(EditMode): total=25, passed=24, failed=0, skipped=1
  - 结果文件: `_tmp_gsplat_pkgtests/Logs/TestResults_gsplat.xml`
- 待你在 Unity Editor 手动复现验证:
  - EditMode 下,鼠标在 SceneView UI(overlay/toolbar/tab)上滑动,不应再出现整体“显示/不显示”闪烁.

### 2026-02-24
- 用户请求: 进入 systematic-debugging,并认为“可能要改变优化策略”.
- 复盘: 我们已经做了多轮基于 Editor 信号(focusedWindow/mouseOverWindow/duringSceneGui)的补强,但仍无法覆盖所有 UI 交互链路.
- 初步根因(架构层面):
  - EditMode 下把 ActiveCameraOnly 的语义建立在“Editor 当前视口信号”上,本质是不可靠的.
  - SceneView 的 overlay/UIElements 区域尤其容易让 `mouseOverWindow` 等信号失真.
  - 这导致 ActiveCameraOnly 会在 SceneView/GameView 间抖动,从而触发“整体显示/不显示”的闪烁.
- 决策(改变策略,先把体验救回来):
  - 在 Editor 非 Play 模式下:
    - `CameraMode=ActiveCameraOnly` 不再尝试自动切换到 GameView.
    - 默认始终选择 SceneView(若存在)作为 ActiveCamera.
    - 只有显式 override(`GsplatActiveCameraOverride`)时才切到 Game/VR 相机.
  - 预期收益:
    - 彻底消灭“鼠标在 SceneView UI 上滑动导致 ActiveCamera 被错误切走”的路径.
  - 代价/取舍:
    - EditMode 下如果你想看 GameView,需要:
      - 临时切到 `CameraMode=AllCameras`,或
      - 给 Game 相机挂 `GsplatActiveCameraOverride` 明确指定.
- 下一步(继续阶段4):
  - 修改 `Runtime/GsplatSorter.cs` 的 EditMode ActiveCamera 选择规则,让其不再依赖 viewport hint 自动切换.
  - 更新 `README.md`/`Documentation~/Implementation Details.md`/OpenSpec spec,保持文档与行为一致.
  - Unity 命令行回归跑 `Gsplat.Tests`(EditMode)确保证据.

### 2026-02-24
- 用户反馈: 仍然闪烁,并且“没有任何相关 log”.
- 结论: 现在必须停止“猜测式修复”,先把证据采集链路做扎实(Phase 1: Root Cause Investigation).
- 本轮行动(证据采集,不直接修复):
  - 新增 Editor 诊断开关:
    - `Runtime/GsplatSettings.cs`: `EnableEditorDiagnostics`
    - `Editor/GsplatSettingsProvider.cs`: Project Settings/Gsplat 暴露 UI
  - 新增诊断工具:
    - `Runtime/GsplatEditorDiagnostics.cs`: 环形缓冲记录事件,并在检测到
      “SceneView 相机触发渲染回调,但当帧没有提交 draw”时自动 dump 近 512 条事件到 Console/Editor.log.
  - 接入采集点:
    - `Runtime/GsplatSorter.cs`: 在 `OnPreCull`/`beginCameraRendering` 记录相机渲染回调,并记录 sort skip/dispatch.
    - `Runtime/GsplatRendererImpl.cs`: 记录 render skip 原因,以及每次对相机提交 draw 的信息.
- 证据型回归(防止改坏编译):
  - Unity 命令行 `_tmp_gsplat_pkgtests`: `Gsplat.Tests`(EditMode) total=25, passed=24, failed=0, skipped=1
- 下一步:
  - 你在 Unity Editor 打开 `Project Settings/Gsplat` 勾选 `EnableEditorDiagnostics`,复现一次闪烁.
  - 如果没有自动 dump,你可以点一次菜单:
    - `Tools/Gsplat/Dump Editor Diagnostics`
  - 我会直接读取 `~/Library/Logs/Unity/Editor.log` 里的 `[GsplatDiag]` dump 来定位根因,再决定下一刀改哪里.

### 2026-02-24 10:00:00 +0800
- 用户反馈: "复现完成,没有任何 log 输出看到".
- 我直接读取了 macOS Unity 日志,发现 log 实际存在,只是被 Unity 日志轮转到了 `~/Library/Logs/Unity/Editor-prev.log`:
  - 仍然存在 Metal 跳绘制 warning(这会导致视口内整体消失,并且 Unity 可能只打印一次,后续静默跳过):
    - `Metal: Vertex or Fragment Shader "Gsplat/Standard" requires a ComputeBuffer at index 3 to be bound, but none provided. Skipping draw calls to avoid crashing.`
  - 诊断 dump 也存在(菜单触发):
    - `[GsplatDiag] DUMP: reason=menu frame=1184`
    - dump 中 `renderedSceneViews` 与 `drawnSceneViews` 一致,说明当时我们确实提交了 draw.
- 结论(Phase 1 证据):
  - 闪烁/消失更像是 "我们提交了 draw,但 Unity/Metal 因为 buffer 绑定缺失而跳过 draw".
  - 这条路径不会触发我现在的 auto-detect("SceneView 渲染了但没提交 draw")规则,也解释了用户体感的"没 log".
- 下一步(改变诊断与修复方向):
  1) 诊断增强:
     - 监听 `Application.logMessageReceived`,一旦捕获到上述 Metal warning,立刻自动 dump `[GsplatDiag]`(把 ring buffer+相机事件吐出来).
     - 在 dump 中额外输出 "shader buffer index -> 属性名" 的映射,明确 index=3 到底对应哪个 buffer.
  2) 修复策略:
     - 不再只依赖 `MaterialPropertyBlock.SetBuffer`.
     - 引入 per-renderer 的 `Material` 实例,把所有 StructuredBuffers 直接 `Material.SetBuffer(...)` 绑定到材质实例上.
       - 目的: 即使某些平台/Unity 版本下 MPB 的 buffer 绑定不稳,材质实例仍能提供稳定绑定,避免 Metal 跳绘制.
     - 同时把 `GraphicsBuffer` 的有效性纳入 `Valid` 检查(避免 buffer 已失效但引用仍非 null).
  3) 验证:
     - 增加一个 EditMode 测试,在有图形设备的 Unity 启动参数下捕获 log,确保不再出现 "ComputeBuffer at index".

### 2026-02-24 10:26:00 +0800
- 诊断增强已完成:
  - `Runtime/GsplatEditorDiagnostics.cs` 现在会捕获 Metal 的 "requires a ComputeBuffer ... Skipping draw calls" warning.
  - 捕获到后会自动 dump `[GsplatDiag]` 并输出 "buffer index -> shader 属性名" 映射.
- 修复已完成(针对 Metal 跳绘制导致的整体闪烁/消失):
  - `Runtime/GsplatRendererImpl.cs` 引入 per-renderer `Material` 实例,把所有 StructuredBuffers 绑定到材质实例作为稳态兜底.
  - `Runtime/GsplatRenderer.cs`/`Runtime/GsplatSequenceRenderer.cs` 增加 buffer 失效的节流自动恢复.
- 回归验证(证据型)已完成:
  - OpenSpec: `openspec validate --all --strict` passed.
  - Unity 命令行(有图形设备,Metal):
    - `Gsplat.Tests.GsplatMetalBufferBindingTests`: passed(1/1)
    - `Gsplat.Tests`: total=26, passed=25, failed=0, skipped=1
- 结论:
  - "Metal 缺 buffer 绑定 -> 跳绘制 -> 视口整体消失/闪烁" 这条路径已被堵住并有回归锁定.
