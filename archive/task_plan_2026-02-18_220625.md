# 任务计划: 输出 OpenSpec change(4DGS)

## 目标
在本仓库初始化 OpenSpec.
生成一个用于实现 4DGS 的 change.
产出可直接进入实现阶段的 artifacts(proposal/specs/design/tasks).

## 阶段
- [x] 阶段1: 现状确认与记录
- [x] 阶段2: 初始化 OpenSpec
- [x] 阶段3: 创建 change 并生成 artifacts
- [x] 阶段4: 输出 changes 状态并交付

## 关键问题
1. change 名称用什么.
2. schema 用默认的 spec-driven 还是自定义.

## 做出的决定
- [决定] change 名称暂定为 `add-4dgs-support`.
  - 理由: 对应当前对话的目标,也符合 kebab-case.
- [决定] schema 使用默认 `spec-driven`.
  - 理由: 当前 openspec 仅提供该 schema,且满足 proposal -> specs -> design -> tasks.

## 状态
**已完成**.
时间: 2026-02-16 17:40:21 +0800.
我正在创建四文件上下文,并准备初始化 OpenSpec,这样后续的 change 和 artifacts 都能落盘可追溯.

## 进展记录
### 2026-02-16 17:41:27 +0800
- 已执行 `openspec init --tools codex`.
- 已生成 `openspec/` 目录,并创建 `.codex/` 以便后续使用 `/opsx:*` 指令与工作流.
- 下一步进入阶段3: 创建 `add-4dgs-support` change,并按 schema 生成 proposal/specs/design/tasks.

### 2026-02-16 17:43:10 +0800
- 已创建 change: `openspec/changes/add-4dgs-support/`.
- 已生成 artifact: `proposal.md`.

### 2026-02-16 17:46:14 +0800
- 已生成 specs:
  - `openspec/changes/add-4dgs-support/specs/4dgs-core/spec.md`
  - `openspec/changes/add-4dgs-support/specs/4dgs-playback-api/spec.md`
  - `openspec/changes/add-4dgs-support/specs/4dgs-vfx-backend/spec.md`
  - `openspec/changes/add-4dgs-support/specs/4dgs-resource-budgeting/spec.md`

### 2026-02-16 17:47:36 +0800
- 已生成 artifact: `design.md`.

### 2026-02-16 17:50:20 +0800
- 已生成 artifact: `tasks.md`.
- `openspec validate add-4dgs-support --strict` 已通过.
- `openspec list` 已能列出 change,并显示 tasks 统计.

---

# 任务计划: 澄清 4DGS 的 VFX 后端定位与 `.splat` 扩展策略

## 目标
在进入实现前,把 VFX Graph 后端的定位与边界讲清楚.
同时明确是否要引入扩展的 `.splat4d` 二进制格式,以及它与 PLY 的关系.

## 阶段
- [x] 阶段1: 回读现有 artifacts,对齐认知
- [x] 阶段2: 调研 SplatVFX 的 VFX Graph 用法与 `.splat` 格式细节
- [x] 阶段3: 给出两条方向,并完成选择
- [x] 阶段4: (如需要)把选择同步回 OpenSpec artifacts 并重新校验

## 关键问题
1. VFX 后端是 "可选工作流后端",还是 "与主后端同等地位,目标 >10M".
2. 是否要定义/支持扩展的 `.splat4d` 二进制格式,还是继续以 PLY 为唯一入口.

## 状态
**已完成**.
时间: 2026-02-16 21:38:27 +0800.
我已把你的选择同步回 OpenSpec artifacts,并通过严格校验.
现在 change 的 scope 与 tasks 已经和 "SplatVFX 风格 + `.splat4d` 一期" 对齐.

## 进展记录
### 2026-02-16 21:12:01 +0800
- 已确认当前 change `add-4dgs-support` 的设计,把 VFX 后端定位为"可选模块 + 明确规模上限".
  - `design.md` 中已写明 "不承诺 VFX Graph 后端支持 >1M 级别的粒子规模".
  - `4dgs-vfx-backend/spec.md` 中要求 `MaxSplatsForVfx` 硬上限,超过自动禁用并告警.
- 已调研 `keijiro/SplatVFX` 的 `.splat` 导入器实现:
  - `.splat` 是无 header 的 raw binary,每个 splat 固定 32 bytes.
  - 字段包含: position(float3), scale(float3), color(rgba8), rotation(4 bytes 量化四元数).
- 下一步: 基于用户目标,在 "VFX 仅作为工作流后端" vs "VFX 也要冲 >10M" 两条路线中做选择.
  - 同步决定 `.splat4d` 是否纳入当前 change,还是作为二期优化.

### 2026-02-16 21:14:30 +0800
- 已从用户处得到明确选择:
  - VFX 后端定位不走 "仅对照" 也不走 "和主后端同等地位冲 >10M".
  - 先按 SplatVFX 的方案改进 VFX 工作流(重点是 ScriptedImporter + prefab + binder + buffer 驱动的 VFX Graph).
  - `.splat4d` 必须纳入一期 tasks,不再作为二期备忘.
- 下一步进入阶段4:
  - 更新 `add-4dgs-support` 的 proposal/design/specs/tasks,把 `.splat4d` 与 SplatVFX 风格工作流写入 artifacts.
  - 重新执行 `openspec validate add-4dgs-support --strict` 确认一致性.

### 2026-02-16 21:38:27 +0800
- 已更新 OpenSpec artifacts,把 `.splat4d` 与 "按 SplatVFX 风格改进 VFX 工作流" 写入:
  - `openspec/changes/add-4dgs-support/proposal.md`
  - `openspec/changes/add-4dgs-support/design.md`
  - `openspec/changes/add-4dgs-support/specs/4dgs-core/spec.md`
  - `openspec/changes/add-4dgs-support/specs/4dgs-vfx-backend/spec.md`
  - `openspec/changes/add-4dgs-support/tasks.md`
- 已通过严格校验: `openspec validate add-4dgs-support --type change --strict --no-interactive`.
- tasks 数量更新为 32 项,`openspec list` 显示 `add-4dgs-support 0/32 tasks`.

---

# 任务计划: 实现 4DGS(`add-4dgs-support`)

## 目标
在当前 Unity 插件(UPM 包)内落地 4DGS 的一期实现:
- 主后端: 现有 Gsplat(Compute 排序 + Gsplat.shader)扩展支持 velocity/time/duration + TimeNormalized 播放.
- 输入: PLY(扩展字段) + `.splat4d`(固定 64 bytes/record 的二进制).
- VFX 工作流: 按 SplatVFX 风格提供 binder 与导入体验增强,但保持 VFX Graph 依赖为可选.

## 阶段
- [x] 阶段1: 数据模型与导入(PLY + `.splat4d`)
- [x] 阶段2: Runtime buffers 上传与绑定
- [x] 阶段3: 排序与渲染(Compute + Shader)的 4D 扩展
- [x] 阶段4: 播放控制 API 与一致性(TimeNormalized)
- [x] 阶段5: Bounds/预算/降级/VFX 后端/文档/验证

## 状态
**目前在阶段5**.
时间: 2026-02-16 23:34:20 +0800.
我已完成阶段4(播放控制 API 与一致性),接下来处理 bounds 扩展、资源预算/降级、VFX 后端、文档与验证步骤.

## 进展记录
### 2026-02-16 23:08:41 +0800
- 已完成任务 1.1-1.5:
  - 扩展 `GsplatAsset` 增加 `Velocities/Times/Durations` 与 `MaxSpeed/MaxDuration`.
  - 扩展 PLY importer: 读取 4D 字段与别名,缺失字段填默认值,并在导入期 clamp + 统计 + warning.
  - 新增 `.splat4d` importer: 固定 64 bytes/record,导入为 `GsplatAsset`(一期 SHBands=0),并在导入期 clamp + 统计 + warning.

### 2026-02-16 23:19:23 +0800
- 已完成任务 2.1-2.4:
  - `GsplatRendererImpl` 新增 `VelocityBuffer/TimeBuffer/DurationBuffer`,并在资源重建与释放中处理完整.
  - `GsplatRenderer` 同步/异步上传路径都支持 4D buffers 上传.
  - `MaterialPropertyBlock` 绑定新增 4D buffers,并预留 `_Has4D/_TimeNormalized` 参数用于后续 shader 扩展.

### 2026-02-16 23:32:08 +0800
- 已完成任务 3.1-3.3 与 4.1-4.3:
  - Compute 排序在 `CalcDistance` 中基于 `pos(t)` 计算深度 key,并对时间窗外写入极端 key.
  - Shader 顶点阶段基于 `pos(t)` 计算动态中心,并对时间窗外做硬裁剪(`discardVec`).
  - Runtime 侧把 `_Has4D/_TimeNormalized` 与 4D buffers 绑定到 compute 与 shader,保证路径一致.

### 2026-02-16 23:34:20 +0800
- 已完成任务 5.1-5.3:
  - 在 `GsplatRenderer` 内增加 `TimeNormalized/AutoPlay/Speed/Loop`,并缓存 `m_timeNormalizedThisFrame`.
  - 排序与渲染都使用同一个缓存时间,避免同帧不一致.

### 2026-02-17 00:18:02 +0800
- 已完成阶段5的剩余任务(6.2/8.x/9.x/10.x),并把 change 全部 tasks 勾选完成:
  - VFX Graph 后端: 新增 `Runtime/VFX/GsplatVfxBinder.cs`,提供 `Samples~/VFXGraphSample`,并让 `.splat4d` 导入尽量自动生成 prefab + binder.
  - Bounds/剔除验证: 提供 sample 脚本 `Samples~/VFXGraphSample/Scripts/Gsplat4DCullingRepro.cs` 与验证清单.
  - 文档同步: 更新 `README.md` 与 `Documentation~/Implementation Details.md`.
  - 验证步骤: 把时间窗裁剪/线性运动/遮挡排序变化/3D-only 回归/HDRP 注入检查写入 sample README.
- OpenSpec 状态:
  - `openspec list --json` 显示 `add-4dgs-support` 为 `complete(32/32)`.
  - `openspec validate add-4dgs-support --strict` 已通过.

---

# 任务计划: 输出 OpenSpec change,并澄清 3DGS 渲染与 VFX Graph 4DGS 的关系

## 目标
把当前仓库的 3DGS 渲染管线讲清楚.
把 `add-4dgs-support` change 的 scope 讲清楚.
解释为什么它不是 "两套同等地位的后端",以及 VFX Graph 后端具体需要做哪些事.

## 阶段
- [x] 阶段1: 回读 OpenSpec artifacts(proposal/specs/design/tasks)
- [x] 阶段2: 回读关键渲染代码(importer/buffers/sort/shader)
- [x] 阶段3: 输出 changes 状态 + 结论

## 状态
**已完成**.
时间: 2026-02-17 00:02:11 +0800.
我已通过回读 `openspec/changes/add-4dgs-support/*` 与关键渲染代码,把 change 的边界与 VFX Graph 的实现要点对齐到 "SplatVFX 风格改进工作流" 这条路线.

---

## 2026-02-17 00:07:12 +0800
- 我正在开始实现 `add-4dgs-support` 的剩余 tasks,原因是你已明确 "退出 explore,开始做 8.x".
- 我将优先完成 VFX Graph 后端(8.x):
  - 增加 `GsplatVfxBinder`,把 GPU buffers 绑定到 `VisualEffect`.
  - 增加 `MaxSplatsForVfx` 硬上限与自动禁用逻辑,避免 VFX Graph 在大规模下失控.
  - 提供 `Samples~` 内的最小可用 VFX Graph sample,并让 `.splat4d` 导入尽量一键生成 prefab + binder.
- 完成 8.x 后,我会继续把剩余的 6.2/9.x/10.x 一并收尾,确保 change 的 tasks 全部勾选,并同步更新文档与验证步骤.

---

# 任务计划: Sync main specs + 归档 change(add-4dgs-support)

## 目标
把 `openspec/changes/add-4dgs-support/specs/*` 的 delta specs 同步到 `openspec/specs/*`.
然后把已完成的 change 按日期归档到 `openspec/changes/archive/`.

## 阶段
- [x] 阶段1: 检查 change 状态(artifacts/tasks)
- [x] 阶段2: Sync delta specs -> main specs
- [x] 阶段3: 归档目录移动
- [x] 阶段4: 归档后校验 + 更新四文件

## 状态
**已完成**.
时间: 2026-02-17.
我已把 delta specs 同步到主 specs,并归档 change `add-4dgs-support`.

## 进展记录
### 2026-02-17
- 已确认 change `add-4dgs-support` artifacts 全部为 done.
- 已确认 tasks 为 complete(32/32),无未勾选项.
- 下一步进入阶段2: 把 delta specs 同步到 `openspec/specs/`.

### 2026-02-17(sync specs)
- 已把 delta specs 同步到主 specs:
  - `openspec/specs/4dgs-core/spec.md`
  - `openspec/specs/4dgs-playback-api/spec.md`
  - `openspec/specs/4dgs-vfx-backend/spec.md`
  - `openspec/specs/4dgs-resource-budgeting/spec.md`
- 下一步进入阶段3: 移动 change 到 `openspec/changes/archive/`.

### 2026-02-17(archive)
- 已归档 change:
  - from: `openspec/changes/add-4dgs-support/`
  - to: `openspec/changes/archive/2026-02-17-add-4dgs-support/`
- 已校验 `openspec list --json` 输出为空 changes,说明 active changes 已清空.
- 下一步: 更新四文件收尾(WORKLOG.md/LATER_PLANS.md/task_plan.md/notes.md).

### 2026-02-17(done)
- 已更新 `WORKLOG.md`,记录 specs sync 与 change 归档结果.
- 本次未新增 `notes.md`/`LATER_PLANS.md` 条目(仍保留既有的二期备忘).
- 本任务结束.

---

# 任务计划: 从动态 3DGS/4DGS 训练仓库导出 `.splat4d`

## 目标
搞清楚 `hustvl/4DGaussians` 的输出数据结构.
给出一条可复现的导出路径,把它映射为本仓库定义的 `.splat4d`(64 bytes/record,position/scale/rgba8/quat8/velocity/time/duration).
同时快速扫读你列出的 4 个参考仓库,判断是否有直接可复用的导出器或数据表达.

## 阶段
- [x] 阶段1: 调研(克隆仓库,定位导出/保存点)
- [x] 阶段2: 数据映射(哪些字段能直接拿,哪些需要推导)
- [x] 阶段3: 生成方案(快速版 vs 拟合版)
- [x] 阶段4: (可选)落地一个 Python 导出脚本 + 文档

## 关键问题
1. 4DGaussians 是否能直接给出 per-gaussian 的 `velocity/time/duration`.
2. 若不能,最靠谱的推导方式是: 从多帧 PLY 做差分/回归,还是从 deformation network 采样求导.
3. 参考仓库里是否已有类似 `.splat`/buffer-friendly 的导出实现.

## 状态
**已完成**.
时间: 2026-02-17.
我已完成 4DGaussians 等仓库的导出点定位与字段映射.
并在本仓库 `Tools~/Splat4D/` 增加了一个从 PLY 序列生成 `.splat4d` 的脚本与说明.

## 进展记录
### 2026-02-17
- 已调研并定位 `hustvl/4DGaussians` 的 per-timestamp PLY 导出脚本:
  - `export_perframe_3DGS.py` 会输出 `gaussian_pertimestamp/time_*.ply`.
- 已确认 4DGaussians 本身不直接提供 `velocity/time/duration`,需要用多时间点采样做差分/分段拟合来生成 `.splat4d`.
- 已快速扫读参考仓库并评估价值:
  - `FreeTimeGsVanilla`: 直接使用 position/velocity/time/duration 的 4D primitive,与 `.splat4d` 语义最接近.
  - `3DGStream`: 更偏“逐帧增量/流式”,缺少直接可用的 velocity/time/duration.
  - `Deformable-3D-Gaussians`: 与 4DGaussians 类似的 deformation 思路,仍需采样推导 velocity/time/duration.
  - `shape-of-motion`: 更偏 4D 重建/预处理与轨迹,可作为上游生成 per-frame 点云/轨迹的候选,但不直接产出 `.splat4d`.
- 已落地工具脚本与文档:
  - `Tools~/Splat4D/ply_sequence_to_splat4d.py`
  - `Tools~/Splat4D/README.md`

---

# 任务计划: 从 FreeTimeGsVanilla(内部 MIT) checkpoint 直接导出 `.splat4d`

## 目标
利用 FreeTimeGsVanilla 的 checkpoint 已经包含 `means/scales/quats/opacities/sh0/times/durations/velocities` 的事实.
实现一个导出器,直接把 `.pt` 写成本仓库 Unity importer 可读的 `.splat4d`.
避免走 "导出 PLY 序列 -> 再差分" 这条更慢的路线.

## 阶段
- [x] 阶段1: 回读 FreeTimeGsVanilla checkpoint 字段语义(尤其 duration)
- [x] 阶段2: 设计映射规则(time/duration 从高斯时间核 -> 硬窗口)
- [x] 阶段3: 落地导出脚本(支持大 N 的分块写入)
- [x] 阶段4: 最小验证(生成 2 条 record 的 mock,确认字节布局)
- [x] 阶段5: 文档补充(写清楚参数与默认值)

## 关键问题
1. FreeTimeGsVanilla 的 `durations` 是 log(sigma),其时间核是高斯函数,不是硬窗口.
2. `.splat4d` 目前是硬窗口语义,需要选一个阈值把 sigma 变成 window.

## 状态
**已完成**.
时间: 2026-02-17.
我已实现从 FreeTimeGsVanilla checkpoint 直接导出 `.splat4d` 的脚本,并完成最小验证与文档补充.

## 进展记录
### 2026-02-17
- 已确认 FreeTimeGsVanilla 的时间核语义:
  - `times` 是 canonical time `mu_t`.
  - `durations` 存的是 `log(sigma)`,viewer 里用 `s = exp(durations)` 作为时间高斯核的 sigma.
  - temporal opacity: `exp(-0.5 * ((t - mu_t) / s)^2)`.
- 已确定 `.splat4d` 的映射规则(把高斯核裁成硬窗口):
  - `half_width = s * sqrt(-2 * ln(temporal_threshold))`.
  - `window = [mu_t - half_width, mu_t + half_width]`(clamp 到 [0,1]).
  - `.splat4d.time = window_start`, `.splat4d.duration = window_len`.
  - 同时把 position 平移到 `time=window_start` 时刻,保证轨迹一致:
    - `pos0 = mu_x + v * (time0 - mu_t)`.
- 已落地导出器(支持分块写入,适配百万级以上 splats):
  - `../FreeTimeGsVanilla/src/export_splat4d.py`
  - 支持参数: `--temporal-threshold/--min-sigma/--chunk-size/--base-opacity-threshold`.
- 已补充 FreeTimeGsVanilla README 的使用说明:
  - `../FreeTimeGsVanilla/README.md`
- 已做最小验证:
  - 用 mock checkpoint 生成 2 条 record 的 `.splat4d`,并用 python struct 解包确认 record layout 与 time/position 的平移逻辑正确.

---

# 任务计划: 检查 4DGaussians 导出的 `gaussian_pertimestamp/` 点数是否一致

## 目标
分析你本机目录 `/Users/cuiluming/local_doc/l_dev/my/unity/gaussian_pertimestamp` 下的 `time_*.ply`,
确认每帧的 vertex 点数(`element vertex N`)是否一致.
并在不一致时,列出异常帧与差异规模,给出下一步可行的 `.splat4d` 生成策略建议.

## 阶段
- [x] 阶段1: 扫描 PLY 序列(读取 header 的 vertex count)
- [x] 阶段2: 汇总统计(帧数,min/max,count 分布,异常帧列表)
- [x] 阶段3: 结论与后续方案(是否可用 index 差分算 velocity)

## 关键问题
1. 点数是否全帧一致(这是 index 差分推 velocity 的前提).
2. 若不一致,差异是偶发(少数帧)还是普遍(大量帧),以及是否存在明显规律(例如后期帧丢点).

## 状态
**已完成**.
时间: 2026-02-17 12:08:41 +0800.
结论: 该目录下 20 帧 PLY 的点数一致,每帧均为 `element vertex 27673`.

## 进展记录
### 2026-02-17
- 扫描范围: `/Users/cuiluming/local_doc/l_dev/my/unity/gaussian_pertimestamp/time_*.ply`(共 20 个文件).
- 点数统计:
  - unique vertex counts: 1
  - vertex_count: 27673(20/20 帧一致)
- header 其它一致性信息(用于排查“偶发导出差异”):
  - format: `binary_little_endian`(20/20 一致)
  - vertex property layout: 62 个字段(20/20 一致)
- 字段检查(与本仓库转换器 `Tools~/Splat4D/ply_sequence_to_splat4d.py` 的要求对齐):
  - 必需字段 `x/y/z,f_dc_0..2,opacity,scale_0..2,rot_0..3` 均存在.
  - 不包含 `vx/vy/vz,time,duration`(说明它是“每时间点 3DGS 采样”,需要离线差分/拟合 velocity 才能变成 `.splat4d`).
- 因此: 这套序列满足“按 vertex index 对齐”这一前提,可以安全使用差分/分段拟合来生成 `.splat4d`.

---

# 任务计划: 修复 `ply_sequence_to_splat4d.py` 的 keyframe 尾段空窗问题

## 目标
当 `--mode keyframe` 且 `(frames - 1)` 不能被 `--frame-step` 整除时,
当前实现会遗漏最后一段时间,导致 `t` 接近 1.0 时 splat 全部不可见.
本任务要把 keyframe 分段逻辑改为“自动补最后一段(可能更短)”,保证时间覆盖到 1.0.

## 阶段
- [x] 阶段1: 修改分段迭代逻辑(覆盖到最后一帧)
- [x] 阶段2: 更新工具文档(说明最后一段可能更短)
- [x] 阶段3: 用本机 `gaussian_pertimestamp` 做一次快速验证(检查最后一段 time0+duration 是否到 1.0)

## 状态
**已完成**.
时间: 2026-02-17 12:47:41 +0800.
我已修复 keyframe 模式的尾段空窗问题,并用本机的 4DGaussians 导出序列做了验证.

## 进展记录
### 2026-02-17
- 已修改 `Tools~/Splat4D/ply_sequence_to_splat4d.py`:
  - keyframe 模式现在会在最后一段不足 `frame_step` 时,自动补一个更短的尾段,保证覆盖到最后一帧(`t=1.0`).
- 已更新 `Tools~/Splat4D/README.md`,补充 keyframe 分段行为与输出规模公式说明.
- 已验证(输入: `gaussian_pertimestamp`,20 帧):
  - `--frame-step 5` 时生成 segments=4.
  - 最终 `.splat4d` 中 `max(time0 + duration) == 1.0`,不再出现尾段不可见.

---

# 任务计划: 用 average 模式把 4DGaussians PLY 序列转换为 `.splat4d`

## 目标
把 `/Users/cuiluming/local_doc/l_dev/my/unity/gaussian_pertimestamp` 的 `time_*.ply`(per-timestamp 3DGS 采样)用 average 模式压缩成 1 个 `.splat4d` 文件,
用于直接拖入 Unity 工程,由 `gsplat-unity` 的 `.splat4d` importer 导入并播放(平均速度 + 全时可见).

## 阶段
- [x] 阶段1: 运行转换器生成 `.splat4d`
- [x] 阶段2: 校验输出文件(大小对齐,record 数,关键字段范围)

## 状态
**已完成**.
时间: 2026-02-17 16:32:24 +0800.
输出: `/Users/cuiluming/local_doc/l_dev/my/unity/gaussian_pertimestamp_average.splat4d`.

## 进展记录
### 2026-02-17
- 输入:
  - `/Users/cuiluming/local_doc/l_dev/my/unity/gaussian_pertimestamp/time_*.ply`(20 帧,每帧 27673 点).
- 命令:
  - `python3 Tools~/Splat4D/ply_sequence_to_splat4d.py --input-dir .../gaussian_pertimestamp --output .../gaussian_pertimestamp_average.splat4d --mode average`
- 输出校验:
  - 文件大小: 1771072 bytes,为 64 的整数倍.
  - record 数: 27673.
  - average 模式写入: `time0=0,duration=1`(全时可见).

---

# 任务计划: 修复 `GsplatVfxBinder` 在部分 Unity/VFX 版本下的编译错误(CS0246)

## 目标
修复用户在 Unity 编译期遇到的错误:
- `Runtime/VFX/GsplatVfxBinder.cs` 中的 `VFXPropertyBinding` / `VFXPropertyBindingAttribute` 找不到(CS0246).

目标是保证:
- 启用 VFX 后端时仍能编译通过.
- binder 的运行时绑定逻辑不受影响.

## 阶段
- [x] 阶段1: 定位编译失败点(确认是属性标注导致)
- [x] 阶段2: 实施兼容性修复(移除非必需的属性标注)
- [x] 阶段3: 记录验证思路与后续建议

## 状态
**已完成**.
时间: 2026-02-17 21:08:36 +0800.

## 进展记录
### 2026-02-17
- 问题:
  - Unity 报错 `CS0246: The type or namespace name 'VFXPropertyBinding' could not be found`.
  - 触发文件: `Runtime/VFX/GsplatVfxBinder.cs`.
- 根因判断:
  - `VFXPropertyBinding` 仅用于 Inspector 更友好的属性绑定 UI.
  - 该属性对运行时绑定并非必需,而且在部分 Unity/VFX Graph 版本中不可用或不可被 Runtime asmdef 引用.
- 修复:
  - 移除 `Runtime/VFX/GsplatVfxBinder.cs` 中所有 `[VFXPropertyBinding(...)]` 标注,仅保留 `[SerializeField]`.
  - 运行时仍通过 `IsValid/UpdateBinding` 里显式调用 `Has*/Set*` 完成校验与写入,功能不依赖该 attribute.

---

# 任务计划: 编写仓库贡献者指南(AGENTS.md)

## 目标
在包根目录新增 `AGENTS.md` 作为贡献者指南.
覆盖: 目录结构,开发命令,代码风格,测试/验证,提交与 PR 约定.

## 阶段
- [x] 阶段1: 回读现有文档与 git 历史,提取约定
- [x] 阶段2: 编写 `AGENTS.md`(200-400 words)并落盘
- [x] 阶段3: 自检与记录(字数/示例/一致性),更新 WORKLOG

## 状态
**已完成**.
时间: 2026-02-18 08:49:53 +0800.
我已新增 `AGENTS.md` 并完成自检,同时把交付记录追加到 `WORKLOG.md`,本任务结束.

## 进展记录
### 2026-02-18
- 已确认仓库核心结构:
  - `Runtime/`(渲染管线与 shaders)
  - `Editor/`(importer 与 editor UI)
  - `Samples~/`(VFX Graph sample)
  - `Documentation~/`(实现细节文档)
  - `Tools~/Splat4D/`(离线生成 `.splat4d`)
- 已确认版本与变更记录文件:
  - `package.json` 版本为 `1.1.2`
  - `CHANGELOG.md` 采用 Keep a Changelog + SemVer
- 已从 git 历史提取提交风格样例:
  - `Supports ... (#6)`
  - `fix: ...`
  - `refactor ...`
  - `v1.1.2`

### 2026-02-18
- 已新增贡献者指南: `AGENTS.md`.
  - 已包含: 目录结构,开发/验证命令示例,代码风格,测试/验证建议,提交与 PR 约定.
  - 字数: 291 words(满足 200-400 words 约束).
  - 已补齐 `AGENTS.md.meta`,避免 Unity 导入时自动生成 meta 导致 GUID 漂移与无意义 diff.

---

# 任务计划: 增加 Unity Test Framework 最小测试骨架

## 目标
在本 UPM 包内新增一个最小的 Unity Test Framework 测试骨架(EditMode),
让贡献者能在 Unity Test Runner 里跑通基础单元测试,并为后续回归提供落点.

## 阶段
- [x] 阶段1: 规划 Tests 目录与 asmdef
- [x] 阶段2: 编写最小 EditMode 单元测试(以 `GsplatUtils` 为主)
- [x] 阶段3: 自检与文档同步,追加 WORKLOG

## 状态
**已完成**.
时间: 2026-02-18 09:41:35 +0800.
我已完成最小 Unity Test Framework 测试骨架的落盘与自检,并同步更新 `AGENTS.md` 与 `WORKLOG.md`,本任务结束.

## 进展记录
### 2026-02-18
- 已回读现有 `.meta` 风格:
  - C# 脚本使用 `MonoImporter`.
  - asmdef 使用 `AssemblyDefinitionImporter`.
  - 目录 meta 在本仓库通常只有 `fileFormatVersion/guid/timeCreated`.
- 已创建目录: `Tests/Editor/`(后续将补齐 `.asmdef` 与最小测试文件).

### 2026-02-18
- 已新增 EditMode 测试程序集:
  - `Tests/Editor/Gsplat.Tests.Editor.asmdef`:
    - `includePlatforms=["Editor"]` 确保只在编辑器侧编译与运行.
    - `optionalUnityReferences=["TestAssemblies"]` 以启用 NUnit/Unity Test Framework 引用.
    - 引用 `Runtime/Gsplat.asmdef`(GUID)以测试 runtime 纯逻辑函数.
- 已新增最小单测文件:
  - `Tests/Editor/GsplatUtilsTests.cs`:
    - 覆盖 `SHBands` 映射,`EstimateGpuBytes` 估算,`CalcWorldBounds` 的基础行为.
    - 选择这些测试的原因: 不依赖 GPU/图形 API,更适合作为 CI 与本地快速回归.
- 已补齐 Unity `.meta`:
  - `Tests.meta`,`Tests/Editor.meta`,以及新 asmdef/脚本的 `.meta`.
- 已同步更新贡献者指南:
  - `AGENTS.md` 的 Testing Guidelines 由 "无自动化测试" 更新为 "EditMode tests 在 `Tests/Editor/`".

---

# 任务计划: 导出 `gaussian_pertimestamp` 的单帧 `.splat4d`(frame 2, frame 5)

## 目标
在本机目录 `/Users/cuiluming/local_doc/l_dev/my/unity/gaussian_pertimestamp/` 中,
把 `time_00002.ply` 与 `time_00005.ply` 分别转换成单帧 `.splat4d`,
用于 Unity 侧导入验证与对照.

## 阶段
- [x] 阶段1: 现状确认(输入文件存在/命名/点数)
- [x] 阶段2: 生成 `.splat4d`(average 模式,单帧目录)
- [x] 阶段3: 校验输出(文件大小/record 数/字段合理性)
- [x] 阶段4: 记录 WORKLOG,交付输出路径

## 关键问题
1. "frame 2/5" 对应的文件是否就是 `time_00002.ply` / `time_00005.ply`.
2. 生成的单帧 `.splat4d` 应该是静态快照(velocity=0,time=0,duration=1),还是仅在该时间片可见.

## 做出的决定
- [决定] 先按“静态快照”导出单帧 `.splat4d`.
  - 理由: 你的表述更像是想要两个可单独导入对照的快照文件.
  - 理由: `average` 模式在输入仅 1 个 PLY 时会自动写入 `velocity=0,time=0,duration=1`,能稳定复用现有工具,不需要改代码.

## 状态
**已完成**.
时间: 2026-02-18 12:48:57 +0800.
我已输出 frame 2/5 的单帧 `.splat4d`,
并完成输出校验与 `WORKLOG.md` 记录.
本任务结束.

## 进展记录
### 2026-02-18 12:45:26 +0800
- 用户需求: 在 `/Users/cuiluming/local_doc/l_dev/my/unity/gaussian_pertimestamp` 基础上,
  输出 frame 2 与 frame 5 的 `.splat4d`.
- 预期输入:
  - frame 2: `time_00002.ply`
  - frame 5: `time_00005.ply`
- 预期输出:
  - `/Users/cuiluming/local_doc/l_dev/my/unity/gaussian_pertimestamp_frame_00002.splat4d`
  - `/Users/cuiluming/local_doc/l_dev/my/unity/gaussian_pertimestamp_frame_00005.splat4d`

### 2026-02-18 12:47:59 +0800
- 已从单帧 PLY 成功导出:
  - frame 2: `/Users/cuiluming/local_doc/l_dev/my/unity/gaussian_pertimestamp_frame_00002.splat4d`
  - frame 5: `/Users/cuiluming/local_doc/l_dev/my/unity/gaussian_pertimestamp_frame_00005.splat4d`
- 输出校验(静态快照):
  - record 数: 27673
  - 文件大小: 1771072 bytes(=27673*64)
  - velocity 全为 0,time=0,duration=1

### 2026-02-18 12:48:57 +0800
- 已追加交付记录到 `WORKLOG.md`.
- 阶段1-4 已全部勾选完成.

---

# 任务计划: 导出 `gaussian_pertimestamp` 的序列 `.splat4d`(keyframe, frame_step=2/5)

## 目标
在本机目录 `/Users/cuiluming/local_doc/l_dev/my/unity/gaussian_pertimestamp/` 中,
基于完整 `time_*.ply` 序列输出两份“序列版”的 `.splat4d`:
- keyframe 分段步长为 2(更高保真,文件更大)
- keyframe 分段步长为 5(更小文件,更少分段)

## 阶段
- [x] 阶段1: 澄清参数含义(确认 keyframe, frame_step=2/5)
- [x] 阶段2: 导出 frame_step=2 的 `.splat4d`
- [x] 阶段3: 导出 frame_step=5 的 `.splat4d`
- [x] 阶段4: 校验输出并记录 WORKLOG

## 关键问题
1. 参数确认: 这里使用 `--mode keyframe --frame-step 2/5` 做分段速度拟合.
2. 这两份输出你希望放在什么路径,以及命名规则.

## 做出的决定
- [决定] 按你的语义把 "`--mode frame 2/5`" 解释为:
  - `--mode keyframe --frame-step 2`
  - `--mode keyframe --frame-step 5`
  - 理由: 这是当前工具唯一和“frame=2/5 两种分段输出序列”匹配的参数组合.
- [决定] 输出路径沿用之前的约定,放到 `/Users/cuiluming/local_doc/l_dev/my/unity/`:
  - `/Users/cuiluming/local_doc/l_dev/my/unity/gaussian_pertimestamp_keyframe_step_00002.splat4d`
  - `/Users/cuiluming/local_doc/l_dev/my/unity/gaussian_pertimestamp_keyframe_step_00005.splat4d`

## 状态
**已完成**.
时间: 2026-02-18 13:03:50 +0800.
我已按 `keyframe` 模式成功导出两份序列 `.splat4d`(frame_step=2/5),
并完成输出大小与关键字段的快速校验.
本任务结束.

## 进展记录
### 2026-02-18 13:01:07 +0800
- 用户反馈: 不要单帧快照,要“序列的 `.splat4d`”,并且要两种输出(frame=2 与 frame=5).
- 当前推断:
  - frame=2 -> `--mode keyframe --frame-step 2`
  - frame=5 -> `--mode keyframe --frame-step 5`

### 2026-02-18 13:03:50 +0800
- 用户确认: "我指的是 keyframe".
- 已导出:
  - `/Users/cuiluming/local_doc/l_dev/my/unity/gaussian_pertimestamp_keyframe_step_00002.splat4d`
    - frames=20,segments=10
    - records=276730,size=17710720 bytes(=276730*64)
  - `/Users/cuiluming/local_doc/l_dev/my/unity/gaussian_pertimestamp_keyframe_step_00005.splat4d`
    - frames=20,segments=4
    - records=110692,size=7084288 bytes(=110692*64)
- 校验要点:
  - `time` 是每个 segment 的起点 t0,`duration` 是该 segment 的 dt,符合 `[0,1]` 时间轴覆盖预期.
  - velocity 非 0(是分段差分得到的速度),用于 `pos(t)=pos0+vel*(t-time0)`.

---

# 任务计划: 评估 `.ksplat` / `.sog` 并规划 `.splat4d` 改版方向

## 目标
为“.splat4d 的下一代 4D 序列格式”做选型与边界定义.
重点解决:
- 大序列文件体积与分发成本.
- Unity 导入峰值内存与导入耗时(尤其是 SH 与 keyframe 序列).
- 未来 SH1-3 与更强压缩的承载方式,避免永远只能靠 PLY.

## 阶段
- [x] 阶段1: 明确两个参考格式(`.ksplat` / `.sog`)的定位
- [x] 阶段2: 调研它们的编码策略与 SH 支持边界
- [ ] 阶段3: 结合 Unity 约束给出两条改版路线(最佳方案 vs 先能用)
- [ ] 阶段4: 选型 + 形成具体 spec(含版本/字段/兼容策略)

## 关键问题
1. 你说的“序列 4DGS”更接近哪一种:
   - A: 我们当前 `.splat4d keyframe` 的“分段 velocity + time/duration 窗口”(piecewise linear).
   - B: 真正逐帧 keyframe positions 的“每帧状态序列”(不做线性拟合,更接近 time_*.ply 的原始表达).
2. 新格式的优先级排序是什么:
   - 文件体积(磁盘/网络) vs 导入速度 vs 运行时显存/带宽 vs SH 画质.
3. 是否接受下列代价:
   - 引入额外依赖(例如 zip/webp 解码).
   - 或者改动 shader/compute,在 GPU 侧解码量化数据(类似 SOG 的思路).

## 初步结论(当前倾向)
- 如果只看 Unity 落地成本:
  - 更偏向 `.ksplat` 这种“单文件二进制容器”的资产形态(减少 asset 碎片,导入实现直白).
- 但在量化/压缩细节上:
  - 更值得借鉴 `.sog` 的公开 spec(例如 position u16 range + codebook + SH palette),它对“体积/带宽”更敏感,也更系统化.

## 状态
**目前在阶段3**.
时间: 2026-02-18 13:15:30 +0800.
我已完成对 `.sog` / `.ksplat` 的快速调研与结论整理.
接下来需要结合你的目标优先级做选型,并把选型固化成可实现的格式 spec.

---

# 任务计划: 创建路线B(SOG风格)的“序列 4DGS 格式”OpenSpec change

## 目标
把“.splat4d 改版为新的序列 4DGS 格式(路线B)”单独开一个 OpenSpec change.
这样我们后续的讨论会:
- 有明确的变更边界与版本化记录.
- 能逐步沉淀为 proposal/specs/design/tasks,方便之后实现与验证.

## 候选路线(用于记录决策背景)
- 路线A(先能用,落地成本低): `.ksplat` 风格的单文件二进制容器 + 压缩等级 + 导入期解码为 float buffers.
- 路线B(不惜代价,最佳方案): `.sog` 风格的纹理流 + 量化/codebook/palette + 尽可能 GPU-native.

## 做出的决定
- [决定] 本任务按路线B推进,先生成 OpenSpec change,再进入细节讨论.
  - 理由: 你的目标是“新的序列格式”,并且希望继承 SOG 的系统性压缩与可扩展属性流设计.

## 阶段
- [x] 阶段1: 确认 change 名称与 workflow schema
- [x] 阶段2: 创建 change scaffold(目录结构)
- [x] 阶段3: 查看 change status + 获取首个 artifact 的 instructions/template
- [ ] 阶段4: 进入 proposal 讨论与起草

## 关键问题
1. change 名称是否用 `sog4d-sequence-format`(kebab-case),还是你有更偏业务的命名.
2. workflow schema 是否沿用默认(spec-driven),还是需要自定义(例如先写 format spec 再写 proposal).

## 状态
**目前在阶段4**.
时间: 2026-02-18 13:32:34 +0800.
我已创建好 change,并拿到了 proposal 的模板与填写要求.
接下来进入“细细讨论”的阶段,我们会把讨论结果直接落到 proposal.md.

## 进展记录
### 2026-02-18 13:32:34 +0800
- 已创建 change: `openspec/changes/sog4d-sequence-format/`(schema: spec-driven).
- 当前 artifacts 状态: 0/4,其中 proposal 已 ready,其它均被 proposal 阻塞.
- 已获取 proposal instructions/template,下一步可以开始起草:
  - `openspec instructions proposal --change "sog4d-sequence-format"`

---

# 任务计划: 修复 `GsplatVfxBinder` 缺少 `VfxComputeShader` 的报错(自动指定默认 compute shader)

## 目标
当用户在 Inspector 中添加 `GsplatVfxBinder` 时,
如果没有手动指定 `VfxComputeShader`,
组件应自动填充为:
- `Packages/wu.yize.gsplat/Runtime/Shaders/GsplatVfx.compute`

最终效果:
- Console 不再反复输出缺少 compute shader 的 error.
- 用户仍可手动覆盖成自定义 compute shader(仅在字段为空时自动填充).

## 候选方案(先记录,再做决定)
- 方案A(不惜代价,最佳方案):
  - 在 `GsplatVfxBinder` 内实现 Editor-only 的“自愈”逻辑:
    - `Reset/OnValidate/OnEnable` 中检测 `VfxComputeShader==null` 时,
      用 `AssetDatabase.LoadAssetAtPath<ComputeShader>(...)` 自动赋值.
  - 优点: 用户手工搭建工作流时也能自动修复,体验最好.
  - 风险: 需要严格 `#if UNITY_EDITOR` 包裹,避免 Player 编译引用 `UnityEditor`.
- 方案B(先能用,后面再优雅):
  - 只修导入器 `GsplatSplat4DImporter`:
    - 确保自动生成 prefab 时总能把 compute shader 赋值进去.
  - 优点: 改动更局部.
  - 缺点: 手工添加 binder 的场景仍会报错,且旧 prefab 仍可能遗留空引用.

## 阶段
- [x] 阶段1: 现象确认与定位(查清字段为何为空)
- [x] 阶段2: 方案选择与设计(确定触发点与边界)
- [x] 阶段3: 代码实现 + 最小回归测试
- [x] 阶段4: 文档与日志同步,交付

## 关键问题
1. 报错来自手工搭建,还是导入器自动生成的 prefab 丢失引用.
2. 自动赋值应覆盖哪些时机:
   - 仅 `Reset/OnValidate`(Inspector 驱动),
   - 还是也在 `OnEnable` 做一次兜底(更稳).

## 做出的决定
- [决定] 选择方案A,在 binder 内做 Editor-only 自动赋值,并在 `OnEnable` 加一层兜底.
  - 理由: 你的报错明确是“未指定 compute shader”,这属于可自愈的配置缺失.
  - 理由: 只修 importer 无法覆盖手工搭建,而 binder 自愈可以覆盖两类场景.

## 状态
**已完成**.
时间: 2026-02-18 14:05:09 +0800.
我已让 `GsplatVfxBinder` 在 Editor 下自动回填默认 `VfxComputeShader`,
并补齐最小回归测试与文档提示.
本任务结束.

## 进展记录
### 2026-02-18 13:58:05 +0800
- 用户现象(来自 Console):
  - `[Gsplat][VFX] GsplatVfxBinder 缺少 VfxComputeShader. 请在 Inspector 中指定为 Packages/wu.yize.gsplat/Runtime/Shaders/GsplatVfx.compute`
  - 调用栈显示报错来自 `GsplatVfxBinder.UpdateBinding(...)`.

---

### 2026-02-18 14:05:09 +0800
- 已在 `Runtime/VFX/GsplatVfxBinder.cs` 增加 Editor-only 自愈逻辑:
  - 在 `Reset/OnValidate/OnEnable` 中,当 `VfxComputeShader==null` 时自动加载并回填.
  - 默认路径: `Packages/wu.yize.gsplat/Runtime/Shaders/GsplatVfx.compute`.
- 已补齐最小回归:
  - `Tests/Editor/Gsplat.Tests.Editor.asmdef` 增加 `GSPLAT_ENABLE_VFX_GRAPH` 的 `versionDefines`.
  - 新增测试 `Tests/Editor/GsplatVfxBinderTests.cs`,锁定“漏配时会自动回填默认 compute shader”.
- 已同步更新样例文档:
  - `Samples~/VFXGraphSample/README.md` 的手工搭建步骤里说明 `VfxComputeShader` 默认会自动填充.

### 2026-02-18 14:00:46 +0800
- 用户对“路线B(SOG风格)序列 4DGS 新格式”的关键确认:
  - 序列语义选择: B(真逐帧 keyframe,不是分段 velocity 拟合).
  - 容器形态选择: 继续走 SOG 思路,并打包成单文件(例如 zip bundle).
  - 依赖接受度: 接受(例如 zip 读取,WebP 解码,必要时 GPU-side 解码).
- 我接下来会在 OpenSpec change `sog4d-sequence-format` 中先落地 proposal(解释 WHY),
  并把后续要写的 specs 能力边界列清楚,为后面的“细细讨论”建立结构化锚点.

### 2026-02-18 14:02:59 +0800
- 已在 change `sog4d-sequence-format` 创建并写入 proposal:
  - 文件: `openspec/changes/sog4d-sequence-format/proposal.md`
  - 当前进度: 1/4 artifacts complete
  - 已解锁: `specs`, `design`
- 下一步(需要继续细化讨论的部分):
  - 先生成 specs 的目录与骨架,把关键问题(时间轴/帧索引/属性流/量化策略/SH 范围/导入输出形态)逐条写成 MUST/SHOULD.

### 2026-02-18 15:01:56 +0800
- 用户补充并确认路线B的关键约束(将固化到 specs):
  - 所有核心属性都需要逐帧可插值: position, scale, rotation, opacity, SH(包含 view-dependent SH).
  - time mapping 同时支持两种:
    - uniform: `t = i/(frameCount-1)`
    - explicit: `frameTimesNormalized[]`
- 我接下来会继续 `sog4d-sequence-format`,开始创建 specs artifact:
  - 新增 capability specs:
    - `sog4d-container`
    - `sog4d-sequence-encoding`
    - `sog4d-unity-importer`
    - `4dgs-keyframe-motion`
  - 修改 capability delta spec:
    - `4dgs-resource-budgeting`

---

# 任务计划: 修复 `GsplatVfxBinderTests` 编译错误(CS0012/CS1061,避免硬依赖 VFX Runtime)

## 目标
修复 EditMode 测试编译错误:
- `GsplatVfxBinder` 不包含 `enabled`(CS1061)
- `VFXBinderBase` 所在程序集未被引用(CS0012)

并且保持 VFX Graph 依赖“可选”:
- 未安装 `com.unity.visualeffectgraph` 的项目不应因为 tests 而编译失败.

## 阶段
- [x] 阶段1: 现象确认与根因定位
- [x] 阶段2: 修复测试实现(消除编译期依赖)
- [x] 阶段3: Unity 刷新编译并拉取 Console 验证
- [x] 阶段4: 同步四文件记录,交付

## 本质(根因)
- 测试 `Tests/Editor/GsplatVfxBinderTests.cs` 之前直接强类型引用 `Gsplat.VFX.GsplatVfxBinder`.
- Unity 的 asmdef 不会自动带上“传递依赖”(transitive dependencies).
  - 因此测试程序集没有显式引用 `Unity.VisualEffectGraph.Runtime` 时,
    编译器无法解析 `GsplatVfxBinder` 的基类 `VFXBinderBase`,
    进而连 `Behaviour.enabled` 都无法解析,导致 CS0012/CS1061 连锁报错.

## 修复策略(做出的决定)
- [决定] 测试改为“反射 + Behaviour”方式,避免对 `Unity.VisualEffectGraph.Runtime` 的编译期硬依赖.
  - 当 binder 类型不存在(例如未安装 VFX Graph 包)时,测试直接 `Assert.Ignore`.
  - 当类型存在时,通过反射清空 `VfxComputeShader`,再用 `Behaviour.enabled` 触发 `OnEnable` 自动回填逻辑.

## 状态
**已完成**.
时间: 2026-02-18 14:21:29 +0800.
我已修复测试编译错误,并通过 Unity MCP 刷新编译确认 Console 没有再出现该组报错.
本任务结束.

## 进展记录
### 2026-02-18 14:21:29 +0800
- 用户反馈编译错误:
  - `GsplatVfxBinderTests.cs`: CS1061/CS0012
- 已修复:
  - `Tests/Editor/GsplatVfxBinderTests.cs` 改为反射方式,移除强类型引用.
- 已用 Unity MCP 验证:
  - `refresh_unity` 请求编译后,Console 未再出现该组编译错误.

---

# 任务计划: 修复 VFX 后端无法随 `TimeNormalized` 播放 4DGS 动画(只在按 `Play()` 时更新)

## 目标
在 VFX Graph 后端下:
- 调整 `GsplatRenderer.TimeNormalized` 时,画面应实时更新.
- 启用 `GsplatRenderer.AutoPlay` 时,应能播放 4DGS 动画(持续更新),而不是只能显示某一帧.

## 阶段
- [x] 阶段1: 现象复现与根因定位(确认是 binder 还是 VFX Graph)
- [x] 阶段2: 设计修复方案(最佳方案 vs 先能用)
- [x] 阶段3: 落地实现(样例 VFX Graph + 兼容性)
- [x] 阶段4: Unity 验证 + 文档/日志同步

## 关键问题
1. 当前 `Samples~/VFXGraphSample/VFX/Splat.vfx` 是否只在 Initialize 阶段采样 `PositionBuffer/ColorBuffer`,
   导致后续 `TimeNormalized` 改变时粒子属性不再更新.
2. 是否需要 Update Context 才能把 buffer 的变化“每帧写回粒子属性”.
3. 是否需要在 Editor 下自动触发一次 `VisualEffect.Play()` 来改善预览体验(避免每次手点 Play).

## 候选方案(至少两条路线)
- 方案A(不惜代价,最佳方案): 修复 VFX Graph 结构
  - 在 `Splat.vfx` 增加 Update Context.
  - 在 Update Context 中每帧采样 `PositionBuffer/ColorBuffer` 并写回粒子属性.
  - 优点: 运行时开销更合理,动画是“真正每帧更新”.
  - 风险: 需要直接修改 `.vfx` YAML,必须小心保持序列化引用一致.
- 方案B(先能用,后面再优雅): binder 侧强制刷新
  - 在 `GsplatVfxBinder.UpdateBinding` 检测到 `TimeNormalized` 变化时调用 `VisualEffect.Reinit()/Play()`.
  - 优点: 不依赖 VFX Graph 的 Update Context,改动集中在 C#.
  - 缺点: 可能导致每帧 Reinit,性能差且可能闪烁(尤其大 splat 数).

## 做出的决定
- [决定] 选择方案A为主,修复 sample 的 VFX Graph(加 Update Context),并尽量避免 binder 侧的“每帧 Reinit”。
  - 理由: 你要的是“动画播放”,VFX Graph 本就应该在 Update 阶段更新粒子属性.
  - 理由: binder 强刷属于兜底手段,更像 workaround,不够优雅且可能引入性能问题.

## 状态
**已完成**.
时间: 2026-02-18 15:15:11 +0800.
我已修复 sample 的 VFX Graph 结构,让 `TimeNormalized` 变化能实时驱动 VFX 后端播放 4DGS 动画.
本任务结束.

## 进展记录
### 2026-02-18 15:15:11 +0800
- 根因确认:
  - `VFXPropertyBinder` 在 `LateUpdate` 每帧调用 `binding.UpdateBinding(m_VisualEffect)`,
    因此 binder 本身并不缺“每帧更新”.
  - 实际问题是 `Samples~/VFXGraphSample/VFX/Splat.vfx` 之前缺失 Update Context,
    只在 Initialize 阶段采样 `PositionBuffer/AxisBuffer/ColorBuffer`.
    这会导致粒子属性在初始化后不再随 buffer 变化而更新,于是看起来只能“按 Play 才更新一帧”.
- 已修改:
  - `Samples~/VFXGraphSample/VFX/InitializeSplat.vfxblock`:
    - `m_SuitableContexts: 2 -> 10`(Init|Update),允许同一 subgraph block 在 Update 阶段复用.
  - `Samples~/VFXGraphSample/VFX/Splat.vfx`:
    - 新增 `VFXBasicUpdate` context,并把 flow 改为: Spawn -> Init -> Update -> Output.
    - 在 Update context 中复用 `InitializeSplat` block,每帧把 position/color/alpha/axis 从 buffer 写回粒子属性.
- Unity 验证:
  - 通过 Unity MCP `refresh_unity` 触发刷新编译并读取 Console,未出现导入/编译错误.

---

# 任务计划: OpenSpec change `sog4d-sequence-format` 补齐 design/tasks,并为后续实现建立锚点

## 目标
- 让 change `sog4d-sequence-format` 的 artifacts 达到 4/4: proposal/specs/design/tasks 全部 ready.
- 把你确认的需求固化成"可落地"的设计约束:
  - 真逐帧 keyframe.
  - position/scale/rotation/opacity/SH 全属性可插值.
  - 同时支持两种 time mapping(uniform + explicit).
- 补齐与 PlayCanvas `.sog/.splat/.ksplat` 的差异解释,避免我们误读其语义.

## 阶段
- [x] 阶段1: 状态核对 + 补充资料引用(确认对标格式细节)
- [x] 阶段2: design.md(导入边界,依赖选型,降级策略,运行时/导入期解码)
- [x] 阶段3: tasks.md(拆分实现任务: tooling/importer/runtime/shader/tests/docs)
- [x] 阶段4: openspec validate 严格校验,并回写四文件记录

## 候选方案(至少两条路线)
- 方案A(不惜代价,最佳方案): 保持运行时压缩优势
  - `.sog4d` 导入后主要保留 quantized textures/buffers.
  - runtime compute/shader 负责解码 + 逐帧插值.
  - 优点: 文件小,带宽小,更接近 SOG 的"GPU-native 纹理流".
  - 风险: shader/compute 复杂度上升,对移动端/老 GPU 更挑剔.
- 方案B(先能用,后面再优雅): 导入期解码为 float buffers
  - `.sog4d` 导入时解码成现有 `.splat4d`/runtime 可直接吃的 float buffers.
  - 优点: 改动最小,最容易在 Unity 跑通.
  - 缺点: 压缩优势只停留在磁盘,导入峰值内存和加载时间可能更大.

## 做出的决定
- [决定] 本 change 先把格式与语义规范化(specs 已写),并在 design.md 里把 A/B 两条落地边界讲清楚.
  - 理由: 你明确希望"逐帧可插值",这会牵扯 Unity 导入输出形态与双帧采样方式,必须先定边界再写 tasks.

## 状态
**已完成**.
时间: 2026-02-18 15:32:45 +0800.
我已补齐 change `sog4d-sequence-format` 的 design/tasks artifacts,并修正 specs 中 requirement 首句必须包含 MUST 的格式问题.
我已运行 `openspec validate sog4d-sequence-format --strict` 并通过.

---

# 任务计划: 同步 Unity 工程 `Assets/Samples` 下的 Gsplat VFX sample 修复

## 目标
让 Unity 工程中被复制出来的 sample:
- `Assets/Samples/Gsplat/1.1.2/VFX Graph Sample(SplatVFX style)`
与包内源 sample:
- `Packages/wu.yize.gsplat/Samples~/VFXGraphSample`
保持一致.

避免你继续使用旧版 `.vfx` 资产时,反复遇到:
- “只能显示某一帧,无法播放动画”
- “拖动 TimeNormalized 不更新,只有按 VisualEffect.Play() 才刷新一帧”

## 阶段
- [x] 阶段1: 核对差异(确认旧版 sample 的缺失点)
- [x] 阶段2: 同步修复文件(仅同步必要文件,不做无关改动)
- [x] 阶段3: Unity MCP 刷新编译并读取 Console(确认无新错误)

## 候选方案(至少两条路线)
- 方案A(不惜代价,最佳方案): 彻底避免 "Samples copy 不自动更新"
  - 删除并重新导入 Sample(让 Unity 重新从 `Samples~` 复制一份最新内容到 `Assets/Samples/...`).
  - 优点: 未来升级包版本时,你心智负担更低.
  - 缺点: 操作需要你手工点几次,而且会丢失你对 Sample copy 的本地改动(如果你改过).
- 方案B(先能用,后面再优雅): 直接同步关键修复到当前 Sample copy(我来做)
  - 只同步 3 个文件:
    - `VFX/InitializeSplat.vfxblock`
    - `VFX/Splat.vfx`
    - `README.md`
  - 优点: 立刻生效,不需要你手工重导 sample.
  - 缺点: 未来如果你更新了 package,Sample copy 仍需再次同步或重导.

## 做出的决定
- [决定] 先执行方案B,把关键修复直接同步到 `Assets/Samples/...` 的那份 copy.
  - 理由: 你现在正在验证功能,优先让“当前项目里正在用的那份资产”立即正确.

## 状态
**已完成**.
时间: 2026-02-18 15:35:59 +0800.
我已把包内 sample 的关键修复同步到 Unity 工程的 `Assets/Samples/...` copy,
这样你不需要重导 sample,就能直接在当前工程里验证 VFX 动画播放是否恢复正常.

## 进展记录
### 2026-02-18 15:35:59 +0800
- 差异确认:
  - Unity 工程中的 sample copy:
    - `Assets/Samples/Gsplat/1.1.2/VFX Graph Sample(SplatVFX style)/VFX/Splat.vfx` 行数较少,缺失 Update Context.
    - `Assets/Samples/.../VFX/InitializeSplat.vfxblock` 仍是 `m_SuitableContexts: 2`,无法在 Update 阶段复用.
- 已同步(从 `Packages/wu.yize.gsplat/Samples~/VFXGraphSample` 覆盖到 `Assets/Samples/...`):
  - `VFX/Splat.vfx`
  - `VFX/InitializeSplat.vfxblock`
  - `README.md`
- Unity 验证:
  - 使用 Unity MCP 触发 `refresh_unity` + 读取 Console,未发现新的导入/编译错误.

---

# 任务计划: 同步外部包目录 `gsplat-unity` 与当前修复保持一致(避免两份包分叉)

## 背景
我在 `st-dongfeng-worldmodel` 的 Unity 工程里看到 `Packages/manifest.json` 当前引用的是外部目录:
- `wu.yize.gsplat`: `file:/Users/cuiluming/local_doc/l_dev/my/unity/gsplat-unity`

这意味着:
- 即使我们已经修复了工程内的 `Assets/Samples/...` copy,
- 只要你未来重新导入 Sample,或者场景使用到包内的 binder 行为,
  仍可能被外部包的旧实现“反向带回”相同问题.

## 目标
把外部目录 `/Users/cuiluming/local_doc/l_dev/my/unity/gsplat-unity` 同步到当前修复后的行为,至少包含:
- `GsplatVfxBinder` 的 Inspector 自愈(默认填充 VfxComputeShader).
- VFX Graph sample 的 Update Context(让 TimeNormalized 播放真正每帧更新).

## 阶段
- [x] 阶段1: 对比外部包与当前包的差异(确认缺失点)
- [x] 阶段2: 同步最小必要文件到外部包(避免无关 diff)
- [ ] 阶段3: (可选)在引用外部包的 Unity 工程里刷新验证

## 候选方案(至少两条路线)
- 方案A(不惜代价,最佳方案): 统一包来源,只维护一份
  - 直接把 Unity 工程的 `wu.yize.gsplat` 依赖切到 `file:Packages/wu.yize.gsplat`,
    让工程只使用仓库内这份包.
  - 优点: 从根上消灭“两份包分叉”风险.
  - 缺点: 需要 Unity 重新解析 packages-lock,可能引发一波依赖刷新.
- 方案B(先能用,后面再优雅): 继续保留外部包引用,但把修复同步过去(我来做)
  - 优点: 不动 Unity 工程依赖配置,立刻让外部包也具备相同修复.
  - 缺点: 仍然存在两份包,未来需要保持同步纪律.

## 做出的决定
- [决定] 先执行方案B,把关键修复同步到外部包 `gsplat-unity`.
  - 理由: 你当前工程 manifest 既然已经引用外部包,我优先保证“你工程实际用到的那份包”也被修好.

## 状态
**目前在阶段3**.
时间: 2026-02-18 15:48:48 +0800.
我已把外部包 `gsplat-unity` 同步到当前修复后的关键行为.
接下来只差在“引用外部包的 Unity 工程”里做一次刷新编译验证(当前 Unity MCP 连接的工程不是该工程,因此这里需要你打开正确工程后我才能继续跑验证).

## 进展记录
### 2026-02-18 15:48:48 +0800
- 差异确认:
  - 外部包 `/Users/cuiluming/local_doc/l_dev/my/unity/gsplat-unity` 仍缺失:
    - `GsplatVfxBinder` 的 Editor 自动回填 `VfxComputeShader`.
    - VFX Graph sample 的 Update Context(因此会继续“只有按 Play 才更新一帧”).
- 已同步最小必要文件到外部包:
  - `Runtime/VFX/GsplatVfxBinder.cs`:
    - Editor 下自动回填默认 `VfxComputeShader`.
    - 缺失报错提示改为复用默认路径常量(避免文案漂移).
  - `Samples~/VFXGraphSample/VFX/InitializeSplat.vfxblock`:
    - `m_SuitableContexts: 2 -> 10`(Init|Update).
  - `Samples~/VFXGraphSample/VFX/Splat.vfx`:
    - 增加 `VFXBasicUpdate` context,并改为 Spawn -> Init -> Update -> Output.
  - `Samples~/VFXGraphSample/README.md`:
    - 同步补充 Update Context 的判断/修复提示,以及 VfxComputeShader 默认值说明.

---

# 任务计划: `sog4d-sequence-format` 设计收敛(支持 SH0-3 + SOG-style 打包)

## 目标
把 `.sog4d`(zip 单文件)的序列编码方案讲清楚,并在进入实现前把最关键的编码细节拍板:
- 必须支持 SH0-3,且可逐帧插值(包含 opacity).
- time mapping 同时支持 uniform + explicit.
- 关键细节对齐 PlayCanvas SOG v2,以最大化互操作性与“压缩优势”.

## 阶段
- [x] 阶段1: 回读现有 change artifacts,确认现状与缺口
- [x] 阶段2: 调研并对齐 SOG v2 的 SH encoding 细节(sh0/shN 的 codebook,labels 打包)
- [x] 阶段3: 做出编码决策并同步回 change specs,然后 strict validate
- [x] 阶段4: 输出实现侧的 Spike 列表与风险清单(仍保持 explore,不写实现代码)

## 关键问题
1. SH0-3 的承载方式,要不要完全复刻 SOG v2 的 `sh0.webp + shN_centroids.webp + shN_labels.webp` 体系.
2. opacity 放在哪里:
   - 单独 `opacity.webp` stream
   - 还是像 SOG 一样塞进 `sh0.webp` 的 alpha
3. u16 labels 的 RG 打包端序:
   - little-endian(`index = r + (g << 8)`)
   - big-endian(`index = (r << 8) + g`)
4. 如果我们要支持 per-frame 插值:
   - `shN` 的 palette(centroids)是全局共享一份,还是允许每帧各自一份.

## 做出的决定
- [决定] opacity 并入 `sh0.webp` alpha,对齐 SOG v2,减少一个 stream.
  - 理由: 更贴近 SOG,也更贴近我们 Unity shader 的输入结构(DC+opacity 在同一个像素/同一个读路径上).
- [决定] labels 的 u16 打包端序采用 little-endian(`index = r + (g << 8)`).
  - 理由: SOG v2 官方示例就是 `index = r + (g << 8)`,对齐它可以减少未来格式互转的坑.
- [决定] SH 的高阶系数(AC)使用 `shN_centroids.bin + shN_labels.webp`(palette + labels),其中 `shN_centroids.bin` 默认 `float16` little-endian.
  - 理由: 性能优先. palette 放在 `.bin` 能避免大量纹理采样,更适合 compute 解码吞吐.
- [决定] per-frame 路径模板中的 `{frame}` 替换规则为十进制 frameIndex,左侧补零到至少 5 位(例如 `00003`).
  - 理由: 便于文件排序与跨工具链一致性,同时对长序列允许自然扩展到更多位数.

## 状态
**已完成**.
时间: 2026-02-18 17:20:11 +0800.
你已确认性能优先的编码选择.
我已把决定同步回 OpenSpec change 的 specs/design/tasks,并通过严格校验.

## 进展记录
### 2026-02-18 17:20:11 +0800
- 已同步编码决策到 change artifacts:
  - `sog4d-sequence-encoding`: 移除独立 `opacity` stream,改为 `sh0.webp` alpha; u16 label 端序改为 little-endian; SH palette 改为 `shN_centroids.bin`(f16/f32) + `shN_labels.webp`.
  - `4dgs-keyframe-motion`: 明确 opacity 来源于 `sh0.webp` alpha.
  - `design`: 固化 SH 承载方式为性能优先版本.
  - `4dgs-resource-budgeting`: 更新资源估算清单(新增 shN_centroids,移除 opacity.webp).
  - `tasks`: 勾选完成 1.1-1.3.
- 已验证: `openspec validate sog4d-sequence-format --strict` 通过.

---

# 任务计划: sog4d-sequence-format 补充 SH codebook 生成策略 + DualGS delta labels

## 目标
把 `shNCount`(palette entry 数)与 `sh0Codebook`/`shN_centroids` 的生成策略写清楚.
同时把 DualGS 的 "labels delta" 思路,以可实现的任务形式补充到 change 的 design/tasks.
保持性能优先,并尽量对齐 SOG 的互操作语义.

## 阶段
- [x] 阶段1: 回读 DualGS 与 DynGsplat compress.py,确认可复用点
- [x] 阶段2: 更新 change design.md(默认值,trade-off,随机访问策略)
- [x] 阶段3: 更新 change tasks.md(Exporter/Importer/Tests 的 delta-v1 任务)
- [x] 阶段4: openspec validate --strict,并回写 notes/WORKLOG/LATER_PLANS

## 关键问题
1. `shNCount` 默认值选多少,以及何时切换到 `delta-v1`.
2. `sh0Codebook`/`shN_centroids` 训练时的采样与 importance weighting 怎么定义.
3. delta 模式下 segment 长度默认值,以及随机跳帧的成本如何控制.

## 状态
**已完成**.
时间: 2026-02-18 18:20:48 +0800.
我已补齐 SH codebook/palette 的生成策略说明,并把 delta labels 的可实现任务写进 change 的 design/tasks.
我已追加修正 DualGS 的 arXiv 链接到 `notes.md`.
我已运行 `openspec validate sog4d-sequence-format --strict`,并通过.

---

# 任务计划: sog4d 默认参数拍板(delta-v1 + shNCount)

## 目标
把 exporter 的默认输出策略定死,减少实现阶段反复改来改去的风险.
同时保持:
- 默认性能优先.
- 若性能无明显差异则质量优先.
- 默认启用 delta labels.

## 阶段
- [x] 阶段1: 记录用户偏好并转成可执行的默认参数
- [x] 阶段2: 同步到 change design/tasks
- [x] 阶段3: openspec validate --strict
- [x] 阶段4: 回写 notes/WORKLOG

## 做出的决定
- [决定] exporter 默认 `shNLabelsEncoding="delta-v1"`(显式写入 meta 字段).
  - 理由: labels 是主要膨胀项,delta 能显著减小 bundle 体积,并允许更大的 palette.
- [决定] exporter 默认 `shNCount=8192`,segment 默认 50 帧.
  - 理由: `bands=3` 且 float16 时,centroids 体积约 0.7MB,通常不是性能瓶颈;更大 palette 更可能提升质量.

## 状态
**已完成**.
时间: 2026-02-18 18:44:20 +0800.
我已把默认值同步到 change 的 `design.md`/`tasks.md`,并通过严格校验.

---

# 任务计划: Apply OpenSpec change `sog4d-sequence-format`(开始实现)

## 目标
按 `openspec/changes/sog4d-sequence-format/tasks.md` 逐条实现 `.sog4d` 的 Unity 导入与运行时播放.
最终让 `.sog4d` 在 Unity 中可直接导入,生成可播放 prefab,并且逐帧可插值(position/scale/rotation/opacity/SH0-3).

## 阶段
- [x] 阶段1: Runtime 数据模型(SequenceAsset/TimeMapping/InterpolationMode)
- [ ] 阶段2: Editor 导入器骨架(ZIP+meta 校验,actionable errors)
- [ ] 阶段3: 导入器解码与资产输出(WebP->Texture2DArray,UnionBounds,prefab)
- [ ] 阶段4: Runtime 播放(Compute 解码+插值,复用排序与渲染)
- [ ] 阶段5: tests/docs/tooling(最小样例,回归测试,导出工具)

## 关键约束(来自 specs)
1. splat identity 必须跨帧稳定(splatCount/layout 恒定).
2. `timeMapping` 同时支持 uniform 与 explicit,并定义边界情况.
3. opacity 必须来自 `sh0.webp` alpha,并可插值.
4. 默认启用 `delta-v1`,且默认 `shNCount=8192`,segment=50(导入期展开为 per-frame labels).

## 状态
**目前在阶段2**.
时间: 2026-02-18 19:55:27 +0800.
我已完成 Runtime 数据模型.
接下来我会实现 `.sog4d` 的 ScriptedImporter 骨架,先把 ZIP+meta 校验做扎实.

### 2026-02-18 20:05:40 +0800
- 我正在继续 apply OpenSpec change `sog4d-sequence-format`,原因是你确认继续推进实现.
- 我将要做的事情(阶段2): 先实现 `.sog4d` 的 ScriptedImporter 骨架,把 ZIP 读取 + `meta.json` 解析 + streams 基础校验做扎实.
  - 这样做的原因: 这是后续 WebP 解码/Texture2DArray 打包/运行时解码插值的前置门槛.
  - 同时它能尽早提供"actionable errors",避免我们在后面被隐式的 null/尺寸不一致拖死.
- 本阶段完成标准:
  - 输入不是 ZIP / 缺少 meta.json / meta.json 结构不合法 / 缺少必需 streams / layout 尺寸不足 / timeMapping 不合法 等情况,都会给出明确的错误提示.
  - 校验通过后,至少能创建一个 `GsplatSequenceAsset`(只填元数据),为后续导入期解码与运行时播放铺路.

### 2026-02-18 20:10:30 +0800
- 已完成 tasks 3.1-3.3: 新增 `.sog4d` importer 骨架,实现 ZIP+meta.json 解析,并对 timeMapping/layout/streams 做完整性校验.
- 下一步(阶段3): 选型并接入 WebP 解码,并把 per-frame streams 实际解码打包为 `Texture2DArray` 子资产.
  - 这一步是后续 Runtime compute 解码+插值的输入来源.

### 2026-02-18 20:18:10 +0800
- 已完成 tasks 3.4-3.6:
  - WebP 解码选型: 目前采用 Unity 内置 `ImageConversion.LoadImage`(Editor 下可用),失败时 fail-fast 并提示可能是 Unity 版本不支持 WebP.
  - 导入期把 position/scale/rotation/sh0/shNLabels(含 delta-v1 展开)打包为 `Texture2DArray` 子资产,并挂到 `GsplatSequenceAsset`.
  - Bounds: 用 position 的 per-frame rangeMin/rangeMax 生成 `PerFrameBounds` 与 `UnionBounds`.
- 已完成 task 3.8(delta-v1):
  - 解析 `shNLabelDeltaV1` 并校验 header 与 meta 一致.
  - 导入期把 delta 展开为逐帧 labels 纹理,保持运行时 O(1) 随机访问.
- 下一步:
  - task 3.7 依赖 `GsplatSequenceRenderer`(4.1/4.2),因此我会先进入 Runtime 播放阶段,实现序列 renderer + 解码插值 compute.

### 2026-02-18 20:25:10 +0800
- 我正在进入 tasks 4.1-4.2(运行时播放骨架),原因是 importer 已经能把 `.sog4d` 变成 `GsplatSequenceAsset + Texture2DArray`.
- 我将要做的事情:
  - 新增 `GsplatSequenceRenderer` 组件,字段对齐 `GsplatRenderer` 的 TimeNormalized/AutoPlay/Speed/Loop.
  - 让它实现 `IGsplat`,并内部持有 `GsplatRendererImpl`,以复用现有的排序与渲染.
- 这样做的原因:
  - 只有先把“序列资产如何接入现有渲染管线”这个锚点打稳,后面的 compute 解码+插值(4.3)才有明确输入输出.

### 2026-02-18 20:29:40 +0800
- 已完成 tasks 4.1-4.2:
  - 新增 `Runtime/GsplatSequenceRenderer.cs`,实现 `IGsplat`,并内部复用 `GsplatRendererImpl`.
  - 播放控制字段对齐 `GsplatRenderer`(TimeNormalized/AutoPlay/Speed/Loop),并缓存 this-frame time.
- 下一步是 task 4.3:
  - 增加序列解码 compute shader,把两帧量化纹理解码+插值写入 float buffers,让排序与渲染真正显示动画.

### 2026-02-18 20:37:30 +0800
- 已完成 tasks 4.3-4.6:
  - 新增 `Runtime/Shaders/GsplatSequenceDecode.compute`,实现两帧解码+插值.
  - `GsplatSequenceRenderer` 在 Update 中先 dispatch 解码 compute,再进入排序(PreCull)与渲染,并共享同一帧缓存的时间.
  - 显式时间轴(explicit)的二分查找与重复时间点 a=0 分支,由 `GsplatSequenceTimeMapping.EvaluateFromTimeNormalized` 提供.
  - 支持 Nearest/Linear 两种插值模式,默认 Linear.
- 已完成 tasks 5.1-5.2:
  - SH0(f_dc+opacity) 由 `sh0.webp + sh0Codebook` 解码并插值写入 ColorBuffer.
  - SH rest 由 `shN_centroids.bin + shN_labels` 解码并逐系数插值写入 SHBuffer.
- 下一步:
  - 现在 `GsplatSequenceRenderer` 已存在,可以回头完成 importer task 3.7: 导入后自动生成可播放 prefab 并设为 main object.
  - 再往后处理资源预算与自动降级(6.*)以及 exporter(7.*).

### 2026-02-18 20:40:50 +0800
- 已完成 task 3.7:
  - `.sog4d` 导入后会自动生成 prefab(挂 `GsplatSequenceRenderer`),并把 prefab 设为 main object.
  - importer 会尝试自动回填默认解码 compute shader(`Runtime/Shaders/GsplatSequenceDecode.compute`).

### 2026-02-18 20:45:40 +0800
- 已完成 tasks 5.3 与 6.1-6.3:
  - 新增 `GsplatUtils.EstimateSog4dGpuBytes`,把 `.sog4d` 的量化纹理与 palette/codebook 纳入 GPU 预算估算.
  - `GsplatSequenceRenderer` 在创建资源前输出估算,并在超过阈值时 warning.
  - 新增 `GsplatSettings.AutoDegradeDisableInterpolation`,高风险时可自动回退到 Nearest.
  - 分配/dispatch 失败会 fail-fast 输出可行动错误,并禁用组件避免持续报错.
- 下一步进入 exporter(7.*)与 tests/docs/samples(8.*).

### 2026-02-18 21:07:48 +0800
- 我正在继续 apply OpenSpec change `sog4d-sequence-format`,因为你明确要求"继续",并且当前实现还缺少 exporter 与回归测试,无法形成可持续的工作流闭环.
- 我将要做的事情(优先级顺序):
  1) 实现离线导出工具 `Tools~/Sog4D/ply_sequence_to_sog4d.py`(tasks 7.1-7.6):
     - 从 `time_*.ply` 读取逐帧 keyframe 属性.
     - 生成 meta.json + WebP 属性图(position/scale/rotation/sh0/shNLabels) + `shN_centroids.bin`.
     - 默认启用 `delta-v1`,默认 `shNCount=8192`,默认 segment=50,并提供参数覆盖.
     - 最终打包为单文件 `.sog4d`(ZIP bundle).
  2) 增加 bundle 自检命令(任务 7.3),把最常见的错误在离线阶段 fail-fast(例如 layout 不足,labels 越界).
  3) 增加 EditMode tests 与最小 `.sog4d` 样例(任务 8.1-8.4),并用测试锁死 importer 的错误语义.
- 这样做的原因:
  - 目前 Unity 侧 importer+runtime playback 已经可以工作,但缺少 exporter 就很难规模化产出数据,也不利于定位压缩/插值问题.
  - specs 明确要求 "scale indices / shN labels 越界必须失败",我们需要补齐 importer 的 fail-fast 校验,并用 tests 防止回归.
